{"vaultName":"Obsidian Vault","lastExport":1746349638281,"pluginVersion":"1.9.2","validBodyClasses":"publish css-settings-manager theme-dark show-inline-title show-ribbon","useCustomHeadContent":true,"useCustomFavicon":false,"files":["공부/이미지/1-hexagonal-architecture.png","공부/이미지/3-Tier 아키텍처.png","공부/이미지/Pasted Image 20250315205713_441.png","공부/데이터베이스.md","공부/컴퓨터 구조.md","공부/프록시.md","공부/헥사고날 아키텍처.md","공부/BE 아키텍처 기초.md","공부/CORS, XSS, CSRF.md","공부/Java 기초.md","공부/JDK, JRE, JVM.md","공부/Json Web Token.md","공부/Network.md","공부/OIDC Login( OAuth2.0 )요청 흐름.md","공부/ORM과 SQL Mapper.md","공부/Web Application과 Spring 동작.md","lib/fonts/94f2f163d4b698242fef.otf","lib/fonts/72505e6a122c6acd5471.woff2","lib/fonts/2d5198822ab091ce4305.woff2","lib/fonts/c8ba52b05a9ef10f4758.woff2","lib/fonts/cb10ffd7684cd9836a05.woff2","lib/fonts/b5f0f109bc88052d4000.woff2","lib/fonts/cbe0ae49c52c920fd563.woff2","lib/fonts/535a6cf662596b3bd6a6.woff2","lib/fonts/70cc7ff27245e82ad414.ttf","lib/fonts/454577c22304619db035.ttf","lib/fonts/52ac8f3034507f1d9e53.ttf","lib/fonts/05b618077343fbbd92b7.ttf","lib/fonts/4bb6ac751d1c5478ff3a.woff2","lib/media/6155340132a851f6089e.svg","lib/html/file-tree.html","lib/scripts/webpage.js","lib/scripts/minisearch.js","lib/media/favicon.png","lib/html/custom-head-content.html","lib/styles/obsidian.css","lib/styles/other-plugins.css","lib/styles/theme.css","lib/styles/global-variable-styles.css","lib/styles/supported-plugins.css","lib/styles/main-styles.css","lib/styles/snippets.css","공부/이미지/3-tier-아키텍처.png"],"mainDependencies":["lib/fonts/94f2f163d4b698242fef.otf","lib/fonts/72505e6a122c6acd5471.woff2","lib/fonts/2d5198822ab091ce4305.woff2","lib/fonts/c8ba52b05a9ef10f4758.woff2","lib/fonts/cb10ffd7684cd9836a05.woff2","lib/fonts/b5f0f109bc88052d4000.woff2","lib/fonts/cbe0ae49c52c920fd563.woff2","lib/fonts/535a6cf662596b3bd6a6.woff2","lib/fonts/70cc7ff27245e82ad414.ttf","lib/fonts/454577c22304619db035.ttf","lib/fonts/52ac8f3034507f1d9e53.ttf","lib/fonts/05b618077343fbbd92b7.ttf","lib/fonts/4bb6ac751d1c5478ff3a.woff2","lib/media/6155340132a851f6089e.svg","lib/html/file-tree.html","lib/scripts/webpage.js","lib/scripts/minisearch.js","lib/media/favicon.png","lib/html/custom-head-content.html","lib/styles/obsidian.css","lib/styles/other-plugins.css","lib/styles/theme.css","lib/styles/global-variable-styles.css","lib/styles/supported-plugins.css","lib/styles/main-styles.css","lib/styles/snippets.css"],"fileInfo":{"공부/이미지/1-hexagonal-architecture.png":{"createdTime":1738825882090,"modifiedTime":1738825896143,"sourceSize":119443,"sourcePath":"공부/이미지/1-hexagonal-architecture.png","exportPath":"공부/이미지/1-hexagonal-architecture.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"공부/이미지/3-Tier 아키텍처.png":{"modifiedTime":1746349638281,"sourceSize":65700,"exportedPath":"공부/이미지/3-tier-아키텍처.png","dependencies":[]},"공부/헥사고날 아키텍처.md":{"modifiedTime":1746349638281,"sourceSize":8908,"exportedPath":"공부/헥사고날-아키텍처.html","dependencies":["공부/이미지/3-tier-아키텍처.png","공부/이미지/1-hexagonal-architecture.png"]},"공부/이미지/3-tier-아키텍처.png":{"createdTime":1738824945018,"modifiedTime":1738824945019,"sourceSize":65700,"sourcePath":"공부/이미지/3-Tier 아키텍처.png","exportPath":"공부/이미지/3-tier-아키텍처.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"lib/fonts/94f2f163d4b698242fef.otf":{"modifiedTime":1746349638281,"sourceSize":66800,"exportedPath":"lib/fonts/94f2f163d4b698242fef.otf","dependencies":[]},"lib/fonts/72505e6a122c6acd5471.woff2":{"modifiedTime":1746349638281,"sourceSize":104232,"exportedPath":"lib/fonts/72505e6a122c6acd5471.woff2","dependencies":[]},"lib/fonts/2d5198822ab091ce4305.woff2":{"modifiedTime":1746349638281,"sourceSize":104332,"exportedPath":"lib/fonts/2d5198822ab091ce4305.woff2","dependencies":[]},"lib/fonts/c8ba52b05a9ef10f4758.woff2":{"modifiedTime":1746349638281,"sourceSize":98868,"exportedPath":"lib/fonts/c8ba52b05a9ef10f4758.woff2","dependencies":[]},"lib/fonts/cb10ffd7684cd9836a05.woff2":{"modifiedTime":1746349638281,"sourceSize":106876,"exportedPath":"lib/fonts/cb10ffd7684cd9836a05.woff2","dependencies":[]},"lib/fonts/b5f0f109bc88052d4000.woff2":{"modifiedTime":1746349638281,"sourceSize":105804,"exportedPath":"lib/fonts/b5f0f109bc88052d4000.woff2","dependencies":[]},"lib/fonts/cbe0ae49c52c920fd563.woff2":{"modifiedTime":1746349638281,"sourceSize":106108,"exportedPath":"lib/fonts/cbe0ae49c52c920fd563.woff2","dependencies":[]},"lib/fonts/535a6cf662596b3bd6a6.woff2":{"modifiedTime":1746349638281,"sourceSize":111708,"exportedPath":"lib/fonts/535a6cf662596b3bd6a6.woff2","dependencies":[]},"lib/fonts/70cc7ff27245e82ad414.ttf":{"modifiedTime":1746349638281,"sourceSize":192740,"exportedPath":"lib/fonts/70cc7ff27245e82ad414.ttf","dependencies":[]},"lib/fonts/454577c22304619db035.ttf":{"modifiedTime":1746349638281,"sourceSize":161376,"exportedPath":"lib/fonts/454577c22304619db035.ttf","dependencies":[]},"lib/fonts/52ac8f3034507f1d9e53.ttf":{"modifiedTime":1746349638281,"sourceSize":191568,"exportedPath":"lib/fonts/52ac8f3034507f1d9e53.ttf","dependencies":[]},"lib/fonts/05b618077343fbbd92b7.ttf":{"modifiedTime":1746349638281,"sourceSize":155288,"exportedPath":"lib/fonts/05b618077343fbbd92b7.ttf","dependencies":[]},"lib/fonts/4bb6ac751d1c5478ff3a.woff2":{"modifiedTime":1746349638281,"sourceSize":7876,"exportedPath":"lib/fonts/4bb6ac751d1c5478ff3a.woff2","dependencies":[]},"lib/media/6155340132a851f6089e.svg":{"modifiedTime":1746349638281,"sourceSize":315,"exportedPath":"lib/media/6155340132a851f6089e.svg","dependencies":[]},"lib/html/file-tree.html":{"modifiedTime":1746349638281,"sourceSize":14315,"exportedPath":"lib/html/file-tree.html","dependencies":[]},"lib/scripts/webpage.js":{"modifiedTime":1746349638281,"sourceSize":47290,"exportedPath":"lib/scripts/webpage.js","dependencies":[]},"lib/scripts/minisearch.js":{"modifiedTime":1746349638281,"sourceSize":29422,"exportedPath":"lib/scripts/minisearch.js","dependencies":[]},"lib/media/favicon.png":{"modifiedTime":1746349638281,"sourceSize":1105,"exportedPath":"lib/media/favicon.png","dependencies":[]},"lib/styles/obsidian.css":{"modifiedTime":1746349638281,"sourceSize":138258,"exportedPath":"lib/styles/obsidian.css","dependencies":[]},"lib/styles/other-plugins.css":{"modifiedTime":1746349638281,"sourceSize":2120,"exportedPath":"lib/styles/other-plugins.css","dependencies":[]},"lib/styles/theme.css":{"modifiedTime":1746349638281,"sourceSize":29047,"exportedPath":"lib/styles/theme.css","dependencies":[]},"lib/styles/global-variable-styles.css":{"modifiedTime":1746349638281,"sourceSize":303,"exportedPath":"lib/styles/global-variable-styles.css","dependencies":[]},"lib/styles/main-styles.css":{"modifiedTime":1746349638281,"sourceSize":23130,"exportedPath":"lib/styles/main-styles.css","dependencies":[]},"lib/styles/snippets.css":{"modifiedTime":1746349638281,"sourceSize":46622,"exportedPath":"lib/styles/snippets.css","dependencies":[]},"lib/html/custom-head-content.html":{"modifiedTime":1746349638281,"sourceSize":7679,"exportedPath":"lib/html/custom-head-content.html","dependencies":[]},"공부/데이터베이스.md":{"modifiedTime":1746349638281,"sourceSize":343036,"exportedPath":"공부/데이터베이스.html","dependencies":[]},"공부/컴퓨터 구조.md":{"modifiedTime":1746349638281,"sourceSize":59824,"exportedPath":"공부/컴퓨터-구조.html","dependencies":[]},"공부/프록시.md":{"modifiedTime":1746349638281,"sourceSize":23994,"exportedPath":"공부/프록시.html","dependencies":[]},"공부/CORS, XSS, CSRF.md":{"modifiedTime":1746349638281,"sourceSize":27789,"exportedPath":"공부/cors,-xss,-csrf.html","dependencies":[]},"공부/Json Web Token.md":{"modifiedTime":1746349638281,"sourceSize":24341,"exportedPath":"공부/json-web-token.html","dependencies":[]},"공부/Network.md":{"modifiedTime":1746349638281,"sourceSize":108986,"exportedPath":"공부/network.html","dependencies":[]},"공부/OIDC Login( OAuth2.0 )요청 흐름.md":{"modifiedTime":1746349638281,"sourceSize":33141,"exportedPath":"공부/oidc-login(-oauth2.0-)요청-흐름.html","dependencies":[]},"공부/ORM과 SQL Mapper.md":{"modifiedTime":1746349638281,"sourceSize":36326,"exportedPath":"공부/orm과-sql-mapper.html","dependencies":[]},"공부/Web Application과 Spring 동작.md":{"modifiedTime":1746349638281,"sourceSize":85386,"exportedPath":"공부/web-application과-spring-동작.html","dependencies":[]},"공부/JDK, JRE, JVM.md":{"modifiedTime":1746349638281,"sourceSize":76847,"exportedPath":"공부/jdk,-jre,-jvm.html","dependencies":[]},"lib/styles/supported-plugins.css":{"modifiedTime":1746349638281,"sourceSize":1637,"exportedPath":"lib/styles/supported-plugins.css","dependencies":[]},"공부/Java 기초.md":{"modifiedTime":1746349638281,"sourceSize":32778,"exportedPath":"공부/java-기초.html","dependencies":[]},"공부/이미지/Pasted Image 20250315205713_441.png":{"modifiedTime":1746349638281,"sourceSize":82165,"exportedPath":"공부/이미지/pasted-image-20250315205713_441.png","dependencies":[]},"공부/BE 아키텍처 기초.md":{"modifiedTime":1746349638281,"sourceSize":31341,"exportedPath":"공부/be-아키텍처-기초.html","dependencies":[]},"공부/이미지/1-hexagonal-architecture.html":{"createdTime":1738825882090,"modifiedTime":1738825896143,"sourceSize":119443,"sourcePath":"공부/이미지/1-hexagonal-architecture.png","exportPath":"공부/이미지/1-hexagonal-architecture.html","showInTree":true,"treeOrder":2,"backlinks":["공부/헥사고날-아키텍처.html"],"type":"attachment","data":null},"공부/이미지/3-tier-아키텍처.html":{"createdTime":1738824945018,"modifiedTime":1738824945019,"sourceSize":65700,"sourcePath":"공부/이미지/3-Tier 아키텍처.png","exportPath":"공부/이미지/3-tier-아키텍처.html","showInTree":true,"treeOrder":3,"backlinks":["공부/헥사고날-아키텍처.html"],"type":"attachment","data":null},"공부/이미지/pasted-image-20250315205713_441.png":{"createdTime":1742039833456,"modifiedTime":1742039833459,"sourceSize":82165,"sourcePath":"공부/이미지/Pasted Image 20250315205713_441.png","exportPath":"공부/이미지/pasted-image-20250315205713_441.png","showInTree":true,"treeOrder":0,"backlinks":[],"type":"media","data":null},"공부/이미지/pasted-image-20250315205713_441.html":{"createdTime":1742039833456,"modifiedTime":1742039833459,"sourceSize":82165,"sourcePath":"공부/이미지/Pasted Image 20250315205713_441.png","exportPath":"공부/이미지/pasted-image-20250315205713_441.html","showInTree":true,"treeOrder":4,"backlinks":["공부/oidc-login(-oauth2.0-)요청-흐름.html"],"type":"attachment","data":null},"공부/데이터베이스.html":{"createdTime":1739331952337,"modifiedTime":1755083331284,"sourceSize":350586,"sourcePath":"공부/데이터베이스.md","exportPath":"공부/데이터베이스.html","showInTree":true,"treeOrder":5,"backlinks":[],"type":"excalidraw","data":null},"공부/컴퓨터-구조.html":{"createdTime":1739153491963,"modifiedTime":1748237765324,"sourceSize":59815,"sourcePath":"공부/컴퓨터 구조.md","exportPath":"공부/컴퓨터-구조.html","showInTree":true,"treeOrder":6,"backlinks":[],"type":"excalidraw","data":null},"공부/프록시.html":{"createdTime":1739679671613,"modifiedTime":1748237155304,"sourceSize":23991,"sourcePath":"공부/프록시.md","exportPath":"공부/프록시.html","showInTree":true,"treeOrder":7,"backlinks":[],"type":"excalidraw","data":null},"공부/헥사고날-아키텍처.html":{"createdTime":1738808938149,"modifiedTime":1743562737174,"sourceSize":8908,"sourcePath":"공부/헥사고날 아키텍처.md","exportPath":"공부/헥사고날-아키텍처.html","showInTree":true,"treeOrder":8,"backlinks":[],"type":"markdown","data":null},"공부/be-아키텍처-기초.html":{"createdTime":1746260083837,"modifiedTime":1746601429021,"sourceSize":31270,"sourcePath":"공부/BE 아키텍처 기초.md","exportPath":"공부/be-아키텍처-기초.html","showInTree":true,"treeOrder":9,"backlinks":[],"type":"excalidraw","data":null},"공부/cors,-xss,-csrf.html":{"createdTime":1739416672948,"modifiedTime":1743829680381,"sourceSize":27789,"sourcePath":"공부/CORS, XSS, CSRF.md","exportPath":"공부/cors,-xss,-csrf.html","showInTree":true,"treeOrder":10,"backlinks":[],"type":"excalidraw","data":null},"공부/java-기초.html":{"createdTime":1740714236446,"modifiedTime":1743829227285,"sourceSize":32778,"sourcePath":"공부/Java 기초.md","exportPath":"공부/java-기초.html","showInTree":true,"treeOrder":11,"backlinks":[],"type":"excalidraw","data":null},"공부/jdk,-jre,-jvm.html":{"createdTime":1739174672088,"modifiedTime":1743744791875,"sourceSize":76847,"sourcePath":"공부/JDK, JRE, JVM.md","exportPath":"공부/jdk,-jre,-jvm.html","showInTree":true,"treeOrder":12,"backlinks":[],"type":"excalidraw","data":null},"공부/json-web-token.html":{"createdTime":1739186177754,"modifiedTime":1755086010939,"sourceSize":24365,"sourcePath":"공부/Json Web Token.md","exportPath":"공부/json-web-token.html","showInTree":true,"treeOrder":13,"backlinks":[],"type":"excalidraw","data":null},"공부/network.html":{"createdTime":1741044818223,"modifiedTime":1748171435477,"sourceSize":109202,"sourcePath":"공부/Network.md","exportPath":"공부/network.html","showInTree":true,"treeOrder":14,"backlinks":[],"type":"excalidraw","data":null},"공부/oidc-login(-oauth2.0-)요청-흐름.html":{"createdTime":1739426978190,"modifiedTime":1748163414192,"sourceSize":33256,"sourcePath":"공부/OIDC Login( OAuth2.0 )요청 흐름.md","exportPath":"공부/oidc-login(-oauth2.0-)요청-흐름.html","showInTree":true,"treeOrder":15,"backlinks":[],"type":"excalidraw","data":null},"공부/orm과-sql-mapper.html":{"createdTime":1741044818201,"modifiedTime":1755086023407,"sourceSize":37551,"sourcePath":"공부/ORM과 SQL Mapper.md","exportPath":"공부/orm과-sql-mapper.html","showInTree":true,"treeOrder":16,"backlinks":[],"type":"excalidraw","data":null},"공부/web-application과-spring-동작.html":{"createdTime":1741044818172,"modifiedTime":1748151817883,"sourceSize":87450,"sourcePath":"공부/Web Application과 Spring 동작.md","exportPath":"공부/web-application과-spring-동작.html","showInTree":true,"treeOrder":17,"backlinks":[],"type":"excalidraw","data":null},"site-lib/fonts/94f2f163d4b698242fef.otf":{"createdTime":1755086040801,"modifiedTime":1755086040801,"sourceSize":66800,"sourcePath":"","exportPath":"site-lib/fonts/94f2f163d4b698242fef.otf","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/72505e6a122c6acd5471.woff2":{"createdTime":1755086040801,"modifiedTime":1755086040801,"sourceSize":104232,"sourcePath":"","exportPath":"site-lib/fonts/72505e6a122c6acd5471.woff2","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/2d5198822ab091ce4305.woff2":{"createdTime":1755086040802,"modifiedTime":1755086040802,"sourceSize":104332,"sourcePath":"","exportPath":"site-lib/fonts/2d5198822ab091ce4305.woff2","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/c8ba52b05a9ef10f4758.woff2":{"createdTime":1755086040802,"modifiedTime":1755086040802,"sourceSize":98868,"sourcePath":"","exportPath":"site-lib/fonts/c8ba52b05a9ef10f4758.woff2","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/cb10ffd7684cd9836a05.woff2":{"createdTime":1755086040803,"modifiedTime":1755086040803,"sourceSize":106876,"sourcePath":"","exportPath":"site-lib/fonts/cb10ffd7684cd9836a05.woff2","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/b5f0f109bc88052d4000.woff2":{"createdTime":1755086040803,"modifiedTime":1755086040803,"sourceSize":105804,"sourcePath":"","exportPath":"site-lib/fonts/b5f0f109bc88052d4000.woff2","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/cbe0ae49c52c920fd563.woff2":{"createdTime":1755086040804,"modifiedTime":1755086040804,"sourceSize":106108,"sourcePath":"","exportPath":"site-lib/fonts/cbe0ae49c52c920fd563.woff2","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/535a6cf662596b3bd6a6.woff2":{"createdTime":1755086040805,"modifiedTime":1755086040805,"sourceSize":111708,"sourcePath":"","exportPath":"site-lib/fonts/535a6cf662596b3bd6a6.woff2","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/70cc7ff27245e82ad414.ttf":{"createdTime":1755086040807,"modifiedTime":1755086040807,"sourceSize":192740,"sourcePath":"","exportPath":"site-lib/fonts/70cc7ff27245e82ad414.ttf","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/454577c22304619db035.ttf":{"createdTime":1755086040806,"modifiedTime":1755086040806,"sourceSize":161376,"sourcePath":"","exportPath":"site-lib/fonts/454577c22304619db035.ttf","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/52ac8f3034507f1d9e53.ttf":{"createdTime":1755086040808,"modifiedTime":1755086040808,"sourceSize":191568,"sourcePath":"","exportPath":"site-lib/fonts/52ac8f3034507f1d9e53.ttf","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/05b618077343fbbd92b7.ttf":{"createdTime":1755086040806,"modifiedTime":1755086040806,"sourceSize":155288,"sourcePath":"","exportPath":"site-lib/fonts/05b618077343fbbd92b7.ttf","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/4bb6ac751d1c5478ff3a.woff2":{"createdTime":1755086040799,"modifiedTime":1755086040799,"sourceSize":7876,"sourcePath":"","exportPath":"site-lib/fonts/4bb6ac751d1c5478ff3a.woff2","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/media/6155340132a851f6089e.svg":{"createdTime":1755086040800,"modifiedTime":1755086040800,"sourceSize":315,"sourcePath":"","exportPath":"site-lib/media/6155340132a851f6089e.svg","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"site-lib/media/2308ab1944a6bfa5c5b8.svg":{"createdTime":1755086040800,"modifiedTime":1755086040800,"sourceSize":278,"sourcePath":"","exportPath":"site-lib/media/2308ab1944a6bfa5c5b8.svg","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"site-lib/html/file-tree-content.html":{"createdTime":1755086041124,"modifiedTime":1755086041124,"sourceSize":6944,"sourcePath":"","exportPath":"site-lib/html/file-tree-content.html","showInTree":false,"treeOrder":0,"backlinks":[],"type":"html","data":null},"site-lib/scripts/webpage.js":{"createdTime":1755083477147,"modifiedTime":1755083477147,"sourceSize":110729,"sourcePath":"","exportPath":"site-lib/scripts/webpage.js","showInTree":false,"treeOrder":0,"backlinks":[],"type":"script","data":null},"site-lib/media/favicon.png":{"createdTime":1755086040607,"modifiedTime":1755086040607,"sourceSize":1105,"sourcePath":"","exportPath":"site-lib/media/favicon.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"site-lib/styles/snippets.css":{"createdTime":1755086041010,"modifiedTime":1755086041010,"sourceSize":46762,"sourcePath":"","exportPath":"site-lib/styles/snippets.css","showInTree":false,"treeOrder":0,"backlinks":[],"type":"style","data":null},"site-lib/styles/obsidian.css":{"createdTime":1755086040952,"modifiedTime":1755086040952,"sourceSize":163819,"sourcePath":"","exportPath":"site-lib/styles/obsidian.css","showInTree":false,"treeOrder":0,"backlinks":[],"type":"style","data":null},"site-lib/styles/theme.css":{"createdTime":1755083477366,"modifiedTime":1755083477366,"sourceSize":29047,"sourcePath":"","exportPath":"site-lib/styles/theme.css","showInTree":false,"treeOrder":0,"backlinks":[],"type":"style","data":null},"site-lib/styles/global-variable-styles.css":{"createdTime":1755086040759,"modifiedTime":1755086040759,"sourceSize":346,"sourcePath":"","exportPath":"site-lib/styles/global-variable-styles.css","showInTree":false,"treeOrder":0,"backlinks":[],"type":"style","data":null},"site-lib/styles/supported-plugins.css":{"createdTime":1755086040759,"modifiedTime":1755086040759,"sourceSize":1161,"sourcePath":"","exportPath":"site-lib/styles/supported-plugins.css","showInTree":false,"treeOrder":0,"backlinks":[],"type":"style","data":null},"site-lib/styles/main-styles.css":{"createdTime":1755083477179,"modifiedTime":1755083477179,"sourceSize":19521,"sourcePath":"","exportPath":"site-lib/styles/main-styles.css","showInTree":false,"treeOrder":0,"backlinks":[],"type":"style","data":null}},"shownInTree":["공부/이미지/1-hexagonal-architecture.png","공부/이미지/1-hexagonal-architecture.html","공부/이미지/3-tier-아키텍처.png","공부/이미지/3-tier-아키텍처.html","공부/이미지/pasted-image-20250315205713_441.png","공부/이미지/pasted-image-20250315205713_441.html","공부/데이터베이스.html","공부/컴퓨터-구조.html","공부/프록시.html","공부/헥사고날-아키텍처.html","공부/be-아키텍처-기초.html","공부/cors,-xss,-csrf.html","공부/java-기초.html","공부/jdk,-jre,-jvm.html","공부/json-web-token.html","공부/network.html","공부/oidc-login(-oauth2.0-)요청-흐름.html","공부/orm과-sql-mapper.html","공부/web-application과-spring-동작.html"],"attachments":["공부/이미지/1-hexagonal-architecture.png","공부/이미지/3-tier-아키텍처.png","공부/이미지/pasted-image-20250315205713_441.png","site-lib/fonts/94f2f163d4b698242fef.otf","site-lib/fonts/72505e6a122c6acd5471.woff2","site-lib/fonts/2d5198822ab091ce4305.woff2","site-lib/fonts/c8ba52b05a9ef10f4758.woff2","site-lib/fonts/cb10ffd7684cd9836a05.woff2","site-lib/fonts/b5f0f109bc88052d4000.woff2","site-lib/fonts/cbe0ae49c52c920fd563.woff2","site-lib/fonts/535a6cf662596b3bd6a6.woff2","site-lib/fonts/70cc7ff27245e82ad414.ttf","site-lib/fonts/454577c22304619db035.ttf","site-lib/fonts/52ac8f3034507f1d9e53.ttf","site-lib/fonts/05b618077343fbbd92b7.ttf","site-lib/fonts/4bb6ac751d1c5478ff3a.woff2","site-lib/media/6155340132a851f6089e.svg","site-lib/media/2308ab1944a6bfa5c5b8.svg","site-lib/html/file-tree-content.html","site-lib/scripts/webpage.js","site-lib/media/favicon.png","site-lib/styles/snippets.css","site-lib/styles/obsidian.css","site-lib/styles/theme.css","site-lib/styles/global-variable-styles.css","site-lib/styles/supported-plugins.css","site-lib/styles/main-styles.css"],"allFiles":["공부/orm과-sql-mapper.html","공부/json-web-token.html","공부/데이터베이스.html","공부/컴퓨터-구조.html","공부/프록시.html","공부/network.html","공부/oidc-login(-oauth2.0-)요청-흐름.html","공부/web-application과-spring-동작.html","공부/be-아키텍처-기초.html","공부/cors,-xss,-csrf.html","공부/java-기초.html","공부/jdk,-jre,-jvm.html","공부/헥사고날-아키텍처.html","공부/이미지/pasted-image-20250315205713_441.png","공부/이미지/pasted-image-20250315205713_441.html","공부/이미지/1-hexagonal-architecture.png","공부/이미지/1-hexagonal-architecture.html","공부/이미지/3-tier-아키텍처.png","공부/이미지/3-tier-아키텍처.html","site-lib/fonts/94f2f163d4b698242fef.otf","site-lib/fonts/72505e6a122c6acd5471.woff2","site-lib/fonts/2d5198822ab091ce4305.woff2","site-lib/fonts/c8ba52b05a9ef10f4758.woff2","site-lib/fonts/cb10ffd7684cd9836a05.woff2","site-lib/fonts/b5f0f109bc88052d4000.woff2","site-lib/fonts/cbe0ae49c52c920fd563.woff2","site-lib/fonts/535a6cf662596b3bd6a6.woff2","site-lib/fonts/70cc7ff27245e82ad414.ttf","site-lib/fonts/454577c22304619db035.ttf","site-lib/fonts/52ac8f3034507f1d9e53.ttf","site-lib/fonts/05b618077343fbbd92b7.ttf","site-lib/fonts/4bb6ac751d1c5478ff3a.woff2","site-lib/media/6155340132a851f6089e.svg","site-lib/media/2308ab1944a6bfa5c5b8.svg","site-lib/html/file-tree-content.html","site-lib/scripts/webpage.js","site-lib/media/favicon.png","site-lib/styles/snippets.css","site-lib/styles/obsidian.css","site-lib/styles/theme.css","site-lib/styles/global-variable-styles.css","site-lib/styles/supported-plugins.css","site-lib/styles/main-styles.css"],"webpages":{"공부/이미지/1-hexagonal-architecture.html":{"title":"1-hexagonal-architecture","icon":"","description":"<img src=\"공부/이미지/1-hexagonal-architecture.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"공부/이미지/1-hexagonal-architecture.png","fullURL":"공부/이미지/1-hexagonal-architecture.html","pathToRoot":"../..","attachments":["공부/이미지/1-hexagonal-architecture.html"],"createdTime":1738825882090,"modifiedTime":1738825896143,"sourceSize":119443,"sourcePath":"공부/이미지/1-hexagonal-architecture.png","exportPath":"공부/이미지/1-hexagonal-architecture.html","showInTree":true,"treeOrder":2,"backlinks":["공부/헥사고날-아키텍처.html"],"type":"attachment"},"공부/이미지/3-tier-아키텍처.html":{"title":"3-Tier 아키텍처","icon":"","description":"<img src=\"공부/이미지/3-tier-아키텍처.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"export/공부/이미지/3-tier-아키텍처.png","fullURL":"공부/이미지/3-tier-아키텍처.html","pathToRoot":"../..","attachments":["공부/이미지/3-tier-아키텍처.html"],"createdTime":1738824945018,"modifiedTime":1738824945019,"sourceSize":65700,"sourcePath":"공부/이미지/3-Tier 아키텍처.png","exportPath":"공부/이미지/3-tier-아키텍처.html","showInTree":true,"treeOrder":3,"backlinks":["공부/헥사고날-아키텍처.html"],"type":"attachment"},"공부/이미지/pasted-image-20250315205713_441.html":{"title":"Pasted Image 20250315205713_441","icon":"","description":"<img src=\"공부/이미지/pasted-image-20250315205713_441.png\" target=\"_self\">","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"export/공부/이미지/pasted-image-20250315205713_441.png","fullURL":"공부/이미지/pasted-image-20250315205713_441.html","pathToRoot":"../..","attachments":["공부/이미지/pasted-image-20250315205713_441.html"],"createdTime":1742039833456,"modifiedTime":1742039833459,"sourceSize":82165,"sourcePath":"공부/이미지/Pasted Image 20250315205713_441.png","exportPath":"공부/이미지/pasted-image-20250315205713_441.html","showInTree":true,"treeOrder":4,"backlinks":["공부/oidc-login(-oauth2.0-)요청-흐름.html"],"type":"attachment"},"공부/데이터베이스.html":{"title":"데이터베이스","icon":"","description":"DatabaseRDBNoSQL컴퓨터 시스템에 저장되는 구조화된 정보또는 데이터들의 조직화된 모음DBMS는 DB에 저장된 데이터에 접근하기 위한 일종의 프록시DB를 구축하는 틀과 데이터 검색,저장 등의 기능들을 제공한다.관계형 데이터데이스는 구조화된 데이터들의 관계를 통해 서비스의 전체 데이터를 나타낸다.구조화된 데이터들의 모음을 Table 혹은 Relation 이라고 부르며,이 테이블에 저장되는 데이터를 Entity라고 부른다. Entity는 테이블의 구조(속성)에 맞춰져서설계되며, 한 테이블에는 다수의 Entity가 존재할 수 있다.Table은 행렬 형태로 표현되는데, 이때의 행을 Tuple / 열을 Attribute 라고 부른다.DBMS에 따라서는 Tuple말고 Record로 불리기도 한다. 관련해서는 그림을 참고하자테이블 내의 각 필드들은 숫자, 날짜, 문자 등의 Type으로 표현된다.RDB에서 핵심적인 부분은 테이블 간의 관계표시다.1:1, 1:N, N:M 의 관계가 존재할 수 있으며 세부적으로 0 or 1 or N 의 관계를 그림으로 표시한다.예를들어, 유저와 상품이 있다고 가정한다면 유저는 0개 이상의 상품을 소유할 수 있으므로아래와 같이 표현된다.또한, 테이블의 각 Tuple들은 테이블 전체에서 자신을 식별할 수 있는 고유의 필드값을 가진다.이를 기본키라고 부르며, RDB에는 이러한 Key들이 여러개 존재한다.이 Key 들은 DB 검색성능 향상을 위한 Index나 테이블 간의 관계표현의 용도로도 사용된다.Key에는 고유한 특징으로 유일성과 최소성이 존재한다.유일성은 해당 필드값으로 튜플이 1개 식별되어야 한다는 의미이며,최소성은 해당 필드값이 최소한의 속성조합으로 이루어져야 한다는 의미이다. 그림에 표시된 Key외에 다른 테이블에서 온 Key를 외래키라고 부르며,2개 이상의 속성이 조합된 키를 복합키라고 부른다nameIDaddressphoneTuple or RecordAttributeField유저상품슈퍼키: 유일성후보키: 최소성기본키대체키모든 Key들은 유일하게 식별되는 필드값이어야 하며,그 중에서 최소의 조합으로 사용될 수 있는 Key들을 후보키라고 부른다후보키는 세부적으로 기본키와 대체키로 구분되며, 기본키가 현재 사용되는 후보키를 의미한다.RDB에는 DB의 논리적인 구조를 표현하는 ERD라는 도구가 존재한다.보통 DB 설계과정에서 테이블간의 관계표현을 위해 사용되는데, 이 과정에서 정규화라는 주요개념이 등장한다.정규화는 관계설정 과정에서 발생하는 이상현상(anomaly)을 제거하기 위한 테이블 분리를 뜻한다.이상현상은 삽입, 삭제, 갱신과정에서 발생하는 논리적인 오류를 뜻한다.( 들어가선 안되는 데이터가 들어가거나, 의도치 않은 데이터가 삭제되거나, 모순이 발생하는 등 )정규화는 크게 6개 정도( 1NF, 2NF, 3NF, BCNF, 4NF, 5NF )가 존재한다.1NF(1정규화)는 필드내의 원자성을 유지하는 과정이다.즉, 한 필드에 2개 이상의 데이터가 존재하는 것을 없애는 과정을 의미한다.2NF(2정규화)는 부분함수 종속성을 제거하는 과정이다.모든 속성들이 기본키로만 식별되어야 하는 것을 의미한다.( 동등한 수준의 테이블로 분리한다 )3NF(3정규화)는 이행적 함수 종속을 제거하는 과정이다.A -&gt; B -&gt; C 와 같은 관계를 제거하는 것을 의미한다.BCNF는 모든 결정자를 후보키로 만드는 과정이다.X -&gt; Y 의 관계에서 X가 결정자를 뜻하며, 이 X에 후보키가 아닌게 오지않도록 하는 것이다.4NF는 다치종속을 제거하는 과정이다.다치종속은 하나의 결정자로 다수의 종속자를 결정할 수 있는 관계를 의미한다.5NF는 조인종속을 제거하는 과정이다.조인종속은 테이블을 분리하고 다시 재결합 했을 때 불필요한 데이터가 생기는 것을 의미한다.정규화의 특성 상 하나의 테이블이 다수로 분리되는 경우가 발생한다.이는 DB 전체에서 중복되는 데이터를 줄이고 이상현상이 방지되는 이점이 있다.하지만, 이는 곧 데이터 조회 시 다수의 테이블을 조인해야 함을 의미하므로, 상황에 따라서는 반대로 반정규화를 수행해야할 수도 있다. MySQL, Oracle, MariaDB, SQLServer ..Redis, MongoDB ...RDB에는 트랜잭션(Tracnsaction) 이라는 주요 개념이 등장한다.트랜잭션은 하나의 작업단위에서 발생하는 모든 DB요청 흐름을 의미한다.( 트랜잭션 자체를 하나의 작업 단위로 봐도 무방하다 )예를 든다면, A가 B로 50원을 송금한다면 1. A 계좌 읽기2. A 계좌 -503. B 계좌 읽기4. B 계좌 +50이러한 과정들이 존재할텐데, 1번부터 4번까지의 과정을 하나로 묶으면 트랜잭션이다.트랜잭션에는 주요한 4가지의 특징이 존재하며, 이는 보통 ACID로 불린다.각각 원자성(A), 일관성(C), 고립성(I), 지속성(D)를 뜻한다.원자성(A)은 트랜잭션에게 애매한 상태가 존재해서는 안됨을 의미한다.즉, [ 트랜잭션은 수행되거나 or 수행되지 않거나 ] 둘 중 하나의 상태만을 가져야 한다는 뜻이다.이 때문에 DBMS는 트랜잭션 실패 시, RollBack 기능을 지원한다.일관성(C)은 트랜잭션에 의해 DB의 여러 규칙과 제약사항이 어겨져서는 안됨을 의미한다.간단하게 말하자면 DB의 무결성을 해쳐서는 안된다는 의미이다.고립성(I)은 각각의 트랜잭션이 서로간에 영향을 끼쳐서는 안됨을 의미한다.트랜잭션은 상호배제의 특성을 띄어야하며, 이와 관련해서는 Isolation Level로 불리는 체계가 존재한다.지속성(D)은 한번 반영된 트랜잭션 내용은 영구적이어야 함을 의미한다.DB에 장애가 발생하더라도 한번 반영된 트랜잭션 내용은 영구적이어야 한다.Isolation LevelIsolation Level은 트랜잭션의 격리수준을 나타내는 용어다.DBMS마다 조금씩 다른 기본값이 사용된다.크게 4가지의 단계가 존재하며, 각 단계수준에 따라 발생할 수있는 이상현상이 3가지 존재한다.1. Read UnCommitted(Dirty Read, Non-Repeatable Read, Phantom Read)commit 되지 않은 데이터를 다른 트랜잭션에서 읽을 수 있음2. Read Committed(Non-Repeatable Read, Phantom Read)commit 된 데이터만 다른 트랜잭션에서 읽을 수 있음3. Repeatable Read(Phantom Read)동일한 데이터를 연속적으로 읽었을 때, 같은 값이 나옴을 보장4. Serializable트랜잭션 간의 완벽한 고립을 보장명심해야할 부분은 격리수준이 올라갈수록 이상현상은 줄어들지만반대로 동시작업 처리능력은 떨어진다는 점이다.Lock을 이용해 다른 트랜잭션의 데이터 접근을 방지하기에 동시에 처리할 수 있는 작업량은 줄어들 수 밖에 없다.ISO/IEC 9075 논문에서 확인가능3가지 이상현상1. Dirty Readcommit 되지 않은 정보를 다른 트랜잭션이 읽음으로써유효하지 않은 데이터가 사용되는 상황[ 예시, 트랜잭션 A, B 가정 / x = 10, y = 20 ]1. A가 x를 읽음 ( x = 10 )2. B가 y에 70을 저장( y = 70 )3. A가 y를 읽음 ( y = 70 )4. A가 x에 x+y를 저장( x = 80 ) + commit5. B가 롤백( y = 20 )A가 롤백된 데이터(70)을 읽어서 연산을 했기에유효하지 않은 데이터로 연산을 하는 이상현상이 생김2. Non-Repeatable Read한 트랜잭션에서 동일한 데이터를 연속적으로 읽었을 때다른 값이 출력되는 상황[ 예시, 트랜잭션 A, B 가정 / x = 10 ]1. A가 x를 읽음 ( x = 10 )2. B가 x를 읽음( x = 10 )3. B가 x에 50 저장( x = 50 ) + commit4. A가 x를 읽음( x = 50 )A라는 하나의 트랜잭션에서 동일한 데이터를 읽었지만다른 값이 출력되므로 정상적이지 않다.3. Phantom Read한 트랜잭션에서 동일한 조건으로 데이터를 읽었을 때다른 갯수의 레코드가 읽히는 상황[ 예시, 트랜잭션 A, B 가정 / x = 10, y = 20 ]1. A가 10 이하의 데이터를 읽음 ( 조회 : x )2. B가 y에 10 저장( y = 10 ) + commit3. A가 10 이하의 데이터를 읽음 ( 조회 : x, y )동일한 조건으로 데이터를 읽었지만,각각의 결과가 다르므로 정상적이지 않다.소개된 격리수준 외에 Snapshot Isolation 이라는 게 있다.이는 위에 소개된 논문을 비판하며 나온 대안이다.각 트랜잭션의 시작시점에서 가장 최근 commit된 정보로 복사본을 생성하고, 각각의 트랜잭션이 해당 복사본으로 작업을 수행한다.만약, commit 시점에서 다른 트랜잭션이 복사본 생성 이후로 관련된 데이터에 commit 한 기록이 있다면 현재 트랜잭션은abort 된다.Isolation Level의 구현Isolation Level을 구현하는데 중요한 개념은 Lock 이다.데이터에 접근할 수 있는 권한을 의미하며, 특정 데이터가 Lock 되어있으면 다른 트랜잭션에서 접근하지 못한다.Lock은 read(공유)/write(베타)로 구분되는데 Read-Lock은 여러개 존재할 수 있으며, Write-Lock은 하나만 존재한다.Write-Lock은 높은 고립성을 가지기 때문에 이 Lock을 걸려는 데이터에는 다른 트랜잭션이 접근할 수 없다.즉, Write-Lock이 걸린 데이터에 Read-Lock을 가지고 접근이 불가하며, 반대로 Read-Lock이 걸린 데이터에 Write-Lock으로 접근할 수 없다.Lock에 있어서 중요한 점은 언제 획득하고 언제 반환하냐는 부분이다이와 관련하여 2개의 단계로 Lock을 관리하는 2-Phase Lock(2PL) 프로토콜이 있다.1. 트랜잭션의 시작 전에 필요한 모든 Lock을 획득하는 Phase 2. 순차적으로 Lock을 반환하기 시작하는 Phase 이는 트랜잭션에 필요한 모든 Lock을 취득해야 동작하므로 고립성이 보장되지만, Lock을 취득하기 까지 기다리는 과정에서 DeadLock 발생 가능성이 있다.[ 상호배제, 환형대기, 비선점, 점유와 대기 ]조건이 충족되어 발생하는 작업이 진행되지 못하는 현상NoSQL은 정해진 구조 없이 데이터를 저장한다. 명칭에서 알 수 있듯이 SQL을 고집하지 않는다.기본적으로 Key - Value 쌍의 데이터 모델을 가지고 있으며 RDB와 용어상의 차이가 존재한다.1. 정형화된 데이터 구조(Table)를 가지지 않기때문에 구조에 영향받지 않고 데이터를 저장할 수 있다.즉, RDB와 비교하여 좀 더 유연한 데이터 저장을 지원한다.예를들어, (이름, 나이) 라는 속성의 데이터를 저장하는 중이라도 정형화된 구조가 없으므로(이름, 나이, 성별) 라는 속성을 가진 데이터를 손쉽게 저장할 수 있다.2. 관계로 데이터를 표현하지 않기때문에 데이터의 중복이 커질 수는 있지만,반대로 Join이 필요없으므로 조회성능이 뛰어나다.3. 일반적으로 RDB 수준의 트랜잭션을 지원하지 않아 데이터 무결성이 깨질 수 있지만,트랜잭션 처리로 인한 처리량 저하가 적으므로 높은 처리량을 가진다.4. 흩어진 DB간의 Join이 필요없으므로 수평적 확장(Scale-Out)이 쉽다.종합하자면, 아래와 같은 장단점을 가진다.[ 장점 ]- 유연한 데이터 저장( 비정형 데이터 )- 뛰어난 조회성능( 낮은 지연시간 )- 손쉬운 Scale-Out- 뛰어난 동시성과 높은 처리량[ 단점 ]- 중복되는 데이터 저장( 낮은 메모리 효율 )- DBMS 단위에서의 스키마를 보장하지 않음- 트랜잭션을 지원하지 않아 무결성 보장 X- Table =&gt; Collection- Row(Tuple, Record) =&gt; Document주로 사용되는 NoSQL DBMS로는 Redis와 MongoDB가 있다.이 중에서 Redis은 보통 In-Memory DB로 활용되며, 캐시용도로 많이 사용된다.일반적인 DB가 Disk 수준에서 데이터를 읽어온다면 Redis는 메모리 수준에 데이터를 저장하기에장치간 처리속도 차이로 인해 빠른 조회속도를 보장한다.Redis를 캐싱 용도로 사용하는 경우에는 데이터의 특징을 살펴봐야한다.메모리 공간은 Disk 공간보다 협소하기 때문에 데이터가 무한정 저장되어서는 안된다.특정한 기간까지만 유효한, 크기가 작은 데이터를 선택해야한다.( Redis를 캐시용 DB로만 생각할 수 있는데, RDB와 AOF 기능을 통한 영구 저장기능도 제공한다 )Join정규화 과정에서는 필연적으로 하나의 테이블이 여럿으로 분리된다.이를통해 저장소 내의 데이터 중복은 줄어들지만, 조회하기 위해서는 흩어진 데이터를 하나로 뭉치는 작업이 필요하다.Join은 여러개의 흩어진 테이블들을 특정한 조건으로 끌어모아 임시테이블을 생성하는 작업이다.생성된 임시 테이블은 메모리 or 디스크에 존재하며, 시스템을 재시작하면 사라진다.WITH 구문을 이용한다면 임시테이블을 실제 존재하는 테이블처럼 사용할 수 있다.Join은 보통 어느 테이블을 중심으로 생각하냐에 따라 종류가 나뉜다.간단하게 다이어그램으로 표현하면 아래와 같다.( 소개된 것 외에 자연조인, 동등조인, 교차조인 등이 더 존재 )LEFT OUTER JOINABLEFT JOINIF B.key NULLABFULL OUTER JOINABINNER JOINABRIGHT OUTER JOINABRIGHT JOINIF A.key NULLABABFULL OUTER JOINIF A.key || B.key NULLIndexJoin 설명에서 말했듯이 Join은 조건을 걸어 탐색한다.Index는 이러한 조건검색에서 조회성능을 높이기 위해관리되는 속성의 정렬된 자료구조를 의미한다.Index는 DB에 튜플이 삽입, 갱신, 삭제될 때마다 함께 갱신되며, 보통 B(B+) tree 구조로 이뤄진다.B-tree 구조는 연속된 메모리 공간에 관련정보가포함될 가능성이 높고, 모든 리프노드가 동등한 레벨을갖추며 범위탐색도 가능하기에 Hash보다 탐색에용이하다.Projection : 특성 속성만 골라서 임시 테이블 생성Selection : 특정 튜플만 골라서 임시 테이블 생성Cardinality : 속성 수 / Degree : 튜플 수Clustered Index와 Non-clusterd IndexClustering이라는 용어는 분산된 다수의 시스템을 하나처럼 사용할 수 있게 하는 것을 의미한다.DBMS에서는 관련된 여러 레코드들을 물리적으로 가깝게 저장하는 개념으로도 사용된다.Index는 조회 성능향상을 위해 정렬된 자료구조를 띄게 만드는 것이다.DBMS에 의해 표시되는 테이블과 데이터들은 실제로 2차 메모리에 저장될 때, 일종의 블록단위로저장된다.Clustered Index는 실제로 2차 메모리에 저장될 때, 인덱스 컬럼을 기준으로 하여실제로 정렬된 형태로 저장되는 것을 의미한다. 즉, 메모리 상에도 정렬된 상태로 저장되기 때문에 블록단위로 데이터를 읽어왔을 때, 관련 데이터가 동일한 블록내에 존재할 가능성이 높으므로 높은 성능을 보인다.반면, Non-clustered Index는 2차 메모리에 저장될 때 정렬된 형태를 유지하지 않는다.실제 데이터와 별도로 데이터의 저장 순서 자체는 인덱스와 다르게 저장된다.관련 데이터들을 정렬시켜 저장하지 않기때문에 메모리에 적재하기 위한 추가작업이 필요하지 않으므로, 인덱스 생성비용이 작은편이다. 하지만, 정렬된 메모리 구조를 띄지 않으므로 조회 시 범위 탐색과 관련 데이터를 찾아내는 데더 많은 블록을 불러와야 할 수 있다.이 두 가지 타입의 인덱스는 서로 연계하여 사용할 수 있다.Clustered Index는 일반적으로 PK에 의해 이미 생성되어 있으므로,Non-clusterd Index를 생성할 때 리프노드를 Clustered Index의 Key 값을 가리키도록구성하는 것이다. Non-Clustered Index의 인덱스 페이지 자체는 해당 컬럼에 대해 정렬된 형태를 띄지만 실제 조회는 Clustered Index 에 의해 저장된 메모리공간을 조회하여 가져오게 된다.데이터 검색RDB에서 사용할 수 있는 검색쿼리 중에서 가장 기초적인 것은 LIKE를 이용한 검색이다.LIKE 검색은 인덱스를 사용하는 특정 상황에서는 뛰어난 성능을 보여주지만 인덱스를 사용할 수 없는 검색조건이 주어지면 전체 테이블을 검색하는 문제가 발생한다.LIKE 검색의 대안으로는 Full-Text 검색이 있다.이는 주어진 문장을 단어 단위로 구분하고, 역색인(단어 -&gt; 위치) 형태의 테이블을 제공함으로써 LIKE검색보다 뛰어난 성능을 지원한다.보통 실제 서비스에서 검색기능은 ElasticSearch(이하 ES) 라는 검색엔진을 사용하는 경우가 많다.ES는 분산 환경으로 구성된 일종의 NoSQL 데이터베이스와 유사하다. 내부적으로 데이터를 NoSQL 방식으로 저장하며 ( 테이블과 유사한 도큐먼트 집합인 인덱스를 관리 )데이터 검색에는 Full-Text 검색방식을 사용한다.또한, 인덱스를 여러 노드로 분산하며, 클러스터링을 통해 다수의 서버(샤드)로 분산해서 저장한다.이 과정에서 노드들은 원본인 Primary와 백업용인 Replica로 분리된다.특정 샤드로 검색요청이 왔을 때, 해당 샤드내의 노드로 불충분한 상황이면 흩어진 샤드들에 HTTP 요청을보내고, 처음 요청이 왔던 샤드에서 취합된 데이터를 바탕으로 검색결과를 반환한다.ES의 장점은 높은 확장성과 고가용성, 그리고 비정형 데이터 핸들링과 같은 부분들을 꼽을 수 있다.Lock의 종류Lock은 데이터 동시성제어를 위해 설정하는 잠금장치와 같다.낙관적 락과 비관적 락, 크게 두 가지로 구분할 수 있다.명칭에서 오는 의미를 파악하면 이해가 편하다.데이터 동시접근 상황에서 낙관적이라는 말은 \"충돌발생이 적을 것이다\"라는 가정을 깔고 간다는 말이된다.낙관적 락은 데이터 접근 충돌이 적을 것이라는 가정을 깔고간다.각각의 레코드에 대한 버전을 관리하며, 조회 시에 읽었던 버전과수정 시에 읽은 버전이 동일한지를 판단한다. 이를통해, 각 버전이 서로다른 경우에만 충돌이 발생했다고 판단하여 Rollback이 이뤄진다.비관적 락은 항상 데이터 접근 충돌이 일어날 것이란 가정을 깔고간다.데이터를 읽는 시점에서부터 Lock을 설정하여 다른 트랜잭션들이해당 레코드에 접근할 수 없도록 한다.작업 효율의 측면에서는 낙관적 락이 더 효과적이다.다른 트랜잭션의 읽기 작업에 영향을 주지 않으므로 더 빠른 처리시간을기대하는게 가능하다.반면, 접근 데이터의 무결성이 중요한 상황이라면 비관적 락을 선택하는게좋다.Record LockGap LockRecord Lock은 Record(Row, 행) 에 걸리는 락을 의미한다.일반적으로 생각하는 데이터 자체에 거는 락으로 볼 수 있다.Record Lock은 DML 쿼리에 항상 발생하는데,일반적으로 MySQL은 INDEX에 Lock을 건다는 점을 기억하자반면, Gap Lock은 범위검색과 같은 상황에서 조회무결성을 유지하기위해 사용된다.예를들어, 10초과 20미만의 범위검색을 한다고 가정해보자.이 경우, Gap Lock이 설정되어 있지 않다면 한 트랜잭션에서동일 조건으로 2회 이상 조회하였을 때 Phantom Read가 발생할 수있다.이러한 예시처럼 Gap Lock은 범위조건 검색의 상황에서발생할 수 있는 Phantom Read를 방지할 수 있다.MySQL 기준으로는 FOR UPDATE를 사용한 SELECT문으로쓰기 락을 걸어주거나, 직접 읽기 락을 설정해주는 것으로 Gap Lock을 설정할 수 있다.앞서 언급된 FOR UPDATE를 활용한 Lock은 Next Key Lock 이라고도 불린다.이는 Record Lock와 Gap Lock을 합친 Lock이다.보통 Gap Lock은 단독 사용보다는 이렇게 Next Key Lock의 형태로사용된다.","aliases":[],"inlineTags":[],"frontmatterTags":["#excalidraw"],"headers":[],"links":[],"author":"","coverImageURL":"","fullURL":"공부/데이터베이스.html","pathToRoot":"..","attachments":[],"createdTime":1739331952337,"modifiedTime":1755083331284,"sourceSize":350586,"sourcePath":"공부/데이터베이스.md","exportPath":"공부/데이터베이스.html","showInTree":true,"treeOrder":5,"backlinks":[],"type":"excalidraw"},"공부/컴퓨터-구조.html":{"title":"컴퓨터 구조","icon":"","description":"KernelUserH/WCPURAMHDD, SSD ....DriverLink ( Frame )Internet IP(Packet)Tansport TCP(Segment), UDP(Datagram) HTTP,HTTPS,SMTP,FTP,SSH,AMQP,ETCApplicationRAM의 일부분 + HDD(SSD) 일부분 =&gt; VM(가상메모리)Socket의 본질은 커널의 프로토콜 요소에 대한 추상화된 인터페이스TCP/IP Socket은 네트워크 통신을 위해 사용된다.IP : Port의 형태를 띄며, PC 내부 프로세스들을 구분한다.외부에서 들어온 요청은 Socket에 해당되는 애플리케이션으로 전달된다.TCP의 경우 Src, Dest의 소켓 쌍으로 구분되며UDP는 Dest 만으로 목적지를 구분할 수 있다.동일 PC 내에서의 프로세스간 통신(IPC)에는 Unix Domain Socket 혹은 Pipe, Message Queue가 사용된다.프로세스는 이를 이용하여 특정 커널 메모리 공간(Pipe, MQ)에 내용을 작성하거나, UDS를 통해 다른 프로세스와 통신한다.ApplicationVM NetworkNIC와 네트워크 연결VM NetworkDockerContainer가상머신Guest OS가상머신은 컴퓨터 시스템 위에서새로운 OS를 설치하고, 가상의 컴퓨터를 하나 생성시스템을 위한 H/W, OS, App에 각각 프로세스 할당Docker는 App과 커널 일부분을 독립적으로 관리기존 컴퓨터 시스템을 그대로 사용하므로할당되는 프로세스가 적어 성능이 뛰어남S/W일종의 NAT 역할k8s App과 커널 일부분을 독립적으로 분리한걸 컨테이너라고 함k8s는 이러한 컨테이너 관리를 위한 시스템Docker에서 컴퓨터 시스템의 OS를 활용하여 각 컨테이너에게 OS를 독립적으로 연결만약, 호스트가 Windows고 컨테이너가 Linux 라면WSL2를 활용하여 Linux 커널시스템을 사용하는 식TCP/IP socket가상메모리는 프로세스마다 할당됨프로세스는 최소 1개의 내부작업자( Thread )를 가짐프로세스에 할당된 가상메모리는 크게 2가지의 영역으로 구분됨1. 1개 이상의 Thread들이 공유하여 사용하는 공유자원( Heap, Static )2. Thread 개인 공간인 ( Thread Local Storage ( Stack ) )공유 자원비공유 자원Heap, MethodStack어떠한 작업(Task)을 수행하는데 있어서 하나의 프로세스 내에서 다수의 스레드를 활용 =&gt; 멀티스레딩다수의 프로세스를 활용 =&gt; 멀티프로세싱이 두 방식은 결합도 가능함OS관점에서 보통Linux는 프로세스 단위의 작업Windows는 스레드 단위의 작업 NICSwitchRouter( NAT )Internet프로세스와 스레드, 동기와 비동기컴퓨터 시스템에는 다양한 프로그램들이 존재하며, 이 프로그램들을 실행하여 CPU와 메모리를 할당받으면 프로세스가 된다.Process 내에는 실질적인 작업을 수행하는 Thread가 존재한다. 최소한의 작업을 위해서는 최소 하나의 Thread가 필요하며, 이를 Main Thread라고 부른다.오늘 날, 일반적으로 CPU는 다수의 코어를 가진다. 이 Core 하나하나가 CPU의 역할을 수행할 수 있으며, 듀얼코어 CPU인 경우에는 2개의 작업을 동시에 처리할 수 있다는 의미가 된다.프로세스에는 작업을 위해 CPU 코어가 할당되며, 프로세스 내부에 다수의 Thread가 존재한다면 한 프로세스가 여러 코어들을 사용할 수도 있다.즉, 정리하자면 N개의 코어를 다수의 Process Thread들이 경합해가며 사용하는 것이다.이렇게 2개 이상의 스레드로 동작하는 프로세스의 작업을 멀티스레딩이라고 부른다.( 이때 경합하는 프로세스가 2개이상이면 멀티프로세싱도 된다 )10개의 작업을 빠르게 수행하려면 어떻게 해야할까? 정답은 10개의 작업자를 두고, 모두 동시에 작업을 시작하는 것이다.하지만 PC에 코어의 수는 한정되어 있다. 따라서 10개의 작업자를 두더라도 모든 작업을 동시에 수행할 수는 없다. 즉, 10개의 작업자들이 서로 작업공간을 차지하기 위해 경쟁해야 한다는 의미이다.( 이 과정에서 선점 or 비선점 방식으로 스레드에게 CPU 자원을 할당하는 스케쥴을 짜는 것을 CPU 스케쥴링 기법이라고 한다 )일반적으로 CPU 코어 수 이하의 스레드 증가는 작업성능의 향상을 가져오지만, 그를 넘어서는 개수의 스레드는 항상 그렇지는 않다는 점을 주의해야 한다.용어를 이용해 말하자면 CPU 코어 수 이상으로 Thread가 증가하면 스레드를 교체하고, 작업순서를 관리하는 등 Context Switching 비용이 증가한다.( 다수의 스레드가 CPU 자원( PC, 레지스터 등 )을 할당 or 해제 받는 과정을 Context Switching 이라고 부른다 )이 외에도 스레드를 증가시킬 때 주의해야 할 부분은 더 있다.우선, 한 프로세스 내의 가상 메모리에는 모든 Thread 들이 공유하는 공유공간이 존재한다.이 공유공간에 여러 Thread들이 서로 접근하게 되면 데이터의 무결성이 깨지게 되므로, 이를 관리하기 위한 비용이 추가된다.이러한 공유공간을 임계영역이라고 부르며, 이 임계영역의 데이터 무결성을 지키기 위한 과정을 동시성 관리라고 한다.( 보통 Lock을 이용해서 다른 Thread가 해당 영역에 접근하지 못하도록 막는다 )또한, 모든 스레드는 작업처리를 위한 자신만의 메모리 공간을 가진다.이는 동작하지 않는 스레드라도 항상 점유하는 공간이므로, 활동하지 않는 스레드가 존재한다면 메모리 공간을 낭비하는 꼴이 된다.그렇다면 동기( Synchronous )와 비동기( Asynchronous )는 무엇일까?동기화라는 용어는 서로다른 두 작업자들의 작업현황을 올바르게 맞추는 과정이다.다르게 말하면 앞선 임계영역의 데이터를 여러 스레드가 사용할 때, 올바른 상태의 데이터를 사용하도록 조정하는 작업을 의미한다.사실 동기와 비동기는 주로 I/O와 함께 이야기된다.프로세스는 작업 도중 입출력 요청( 프로세스 외부장치와의 소통 )을 만나게되면 해당 작업을 처리하는 동안 기존작업을 수행하지 않는다.이렇게 I/O 작업동안 기존 작업중인 스레드가 멈추는 것을 동기 I/O 라고 부른다.비동기 I/O는 반대로 입출력 요청을 만났을 때, 다른 스레드에게 작업을 넘기고 기존작업을 이어가는 작업을 의미한다. 즉, 비동기 작업을 위해서는 멀티스레딩이나 이벤트 기반의 프로그래밍이 필요하다.블로킹/논블로킹은 동기/비동기와 유사하지만 관점의 차이가 있다.동기작업의 경우, I/O 작업동안 기존 작업흐름을 막아버린다(Blocking).따라서, 이때의 I/O 작업은 블로킹 I/O가 된다.비동기 작업의 경우, I/O 작업을 다른 스레드에게 넘기고 자신은 기존작업을 이어서 진행한다.즉, 기존 작업을 막지 않기(Non-Blocking) 때문에 이때의 I/O 작업은 논블로킹 I/O가 된다.관점에 따라 동기/비동기, 블로킹/논블로킹을 구분하면엄연히 다른 개념인걸 알 수 있다.동기/비동기는 현재 수행중인 작업에 초점이 맞춰져 있고블로킹/논블로킹은 새롭게 호출되는 작업에 초점이 맞춰져 있다.프로세스 메모리 관리여러개의 프로세스들은 OS로부터 주 메모리 자원을 할당받아 사용한다.보통 RAM + HDD(SSD)를 가상메모리(VM) 라는 명칭으로 할당받아서 사용하게 된다.이때, 프로세스에게 어떤 방식으로 메모리(RAM)를 할당하는지에 대해 알아보자.크게 [ 연속적인 메모리 할당 ]과 [ 비연속적인 메모리 할당 ]이 존재한다.연속적인 메모리 할당은 프로세스의 동작순서대로 메모리 공간을 처음부터 할당하는 방식이다.메모리의 시작지점을 0으로 가정한다면 20의 크기를 P1에게 할당할 때, 0 ~ 20까지를 할당하고이후 P2에게 30의 크기를 할당한다면 20 ~ 50까지를 할당하는 방식이다.프로세스들은 종료되면서 메모리를 반환하게 되는데, 이 과정에서 할당된 메모리 사이에 남은 공간이생기게 되고, 이 공간을 활용하지 못하는 경우가 발생한다. 이를 [ 단편화 ] 라고 부른다.단편화는 내부/외부로 구분된다.[ 내부 단편화 ]는 프로세스가 필요로 하는 크기보다 큰 메모리 영역을 할당하는 경우에 발생한다.이는 OS가 메모리를 할당하는 최소단위와 프로세스가 필요로하는 단위의 차이에서 발생한다.[ 외부 단편화 ]는 메모리 할당과 반환의 반복으로 인해서 할당된 메모리 영역 사이에 발생한 공간을의미한다. 작은 단위의 메모리 공간이 군데군데 존재하게 되는 현상이다.비연속적인 메모리 할당은 한 프로세스가 요구하는 메모리 공간을 여러 곳으로 분산할당하는 방식이다.연속적인 메모리 할당이 프로세스가 원하는 0 ~ 20의 공간을 할당해준다면,비연속적인 메모리 할당은 [ 0 ~ 5 / 10 ~ 15 / 30 ~ 40 ] 이런 식으로 총합 20의 크기는 맞춰주되, 실제 메모리 연속된 공간을 필요로하지 하지 않으므로, 단편화 문제가 완화된다.이렇게 되면, 가상 메모리에서 실제 메모리 공간에 접근해야 할 때, 문제가 발생할 수 있으므로별도의 페이징(세그멘테이션) 테이블을 이용하여 가상메모리 주소와 실제 메모리 주소를 매핑한다.앞서 언급된 페이징과 세그멘테이션은 어떤 단위로 구분하여 메모리를 할당하냐는 차이가 있다.페이징은 고정된 크기 단위로 메모리를 할당하며, 세그멘테이션은 논리적으로 구분된 가변 크기 단위로 할당한다.두 방법 모두 별도의 테이블을 관리해야 한다는 점에서 추가비용이 발생하지만, 연속적인 메모리 할당에 비해 단편화가 발생하더라도 메모리 할당이 유연하다는 장점이 있다.다만, 비연속적인 할당이라도 단편화 현상이 발생한다는 점은 유의하자.페이징은 크기가 고정되어 있으므로 내부 단편화 문제의 가능성이 있으며,세그멘테이션은 외부 단편화 문제가 생길 수 있다. ","aliases":[],"inlineTags":[],"frontmatterTags":["#excalidraw"],"headers":[],"links":[],"author":"","coverImageURL":"","fullURL":"공부/컴퓨터-구조.html","pathToRoot":"..","attachments":[],"createdTime":1739153491963,"modifiedTime":1748237765324,"sourceSize":59815,"sourcePath":"공부/컴퓨터 구조.md","exportPath":"공부/컴퓨터-구조.html","showInTree":true,"treeOrder":6,"backlinks":[],"type":"excalidraw"},"공부/프록시.html":{"title":"프록시","icon":"","description":"ProxyABProxyProxy의 개념은 네트워크와 애플리케이션 등 여러 분야에서 폭넓게 사용되기 때문에 반드시 알아둬야하는 개념 중 하나다.프록시는 위 그림처럼, 목적지에 접근을 대리해서 해주는 객체를 의미한다.\"대리\"해서 작업을 처리해주는 것이기 때문에 보통 3가지의 목적( 우회, 보호, 감시 )로 사용된다.구성위치에서 볼 수 있듯이 직접적으로 대상목표에 다다르지 않고, 프록시에게 방문을 요청함으로써 동일한 업무를 수행할 수 있다.예를들어, A에서 B로의 직접적인 요청이 보안정책으로 막혀있다고 생각해보자.만약 A에서 접근할 수 있는 C라는 곳이 있고, C에서는 B로 요청이 가능하다면 C를 프록시로 사용하여 우회접근이 가능해진다.또한, 외부와 내부를 분리해야 하는 상황이라고 생각해보자.내부 환경은 보안 등의 목적으로 외부에서의 접근을 차단해야하지만, 권한을 가진 대상에게는 접근을 허락해야하는 상황인 것이다.이 경우, 내부로의 접근을 프록시라는 인터페이스를 통해서 이뤄지도록 제한하는게 가능하다.이렇게 구성하면 외부에서의 모든 접근을 검사하고 분기하는 역할을 프록시에게 맡기는 보호의 역할을 수행할 수 있다.마지막으로, 내부에서 외부로 접근하려는 상황을 생각해보자.이 경우에도 프록시를 외부로 접근하기 위한 거름망의 역할로 사용할 수 있다.이렇게 되면 외부로의 접근기록이 프록시에 남게되고, 상황에 따라서는 차단도 가능하기 때문에 특정 객체가 어디로 어떤 요청을보내는지 감시하는게 가능하다.이 프록시는 보통 3가지의 종류로 구분되는데, 리버스 프록시 : 우회와 보호, 감시( 외부 트래픽 )포워드 프록시 : 우회와 보호, 감시( 내부 트래픽 )투명 프록시 : 감시로 나타낼 수 있다.리버스와 포워드 프록시의 구분이 모호할 수 있는데, 리버스(Reverse)의 경우 외부 -&gt; 내부로 들어오는 요청을 검사, 분기, 필터링하며포워드(Forward)의 경우 내부 -&gt; 외부로 나가는 요청을 대리해서 수행하는 차이가 있다.Web에서 Proxy의 사용 예시Web 개발을 하다보면 Proxy를 이곳저곳에서 손쉽게 만날 수 있다.대표적인 사례로는 Nginx를 리버스 프록시로 사용하여 로드밸런싱을 하는 경우, Web 요청/응답이 거치게되는 Filter, Interceptor, Spring의 AOP 가 있다.예를들어, 프로젝트를 진행할 때 Nginx, React, Spring Boot로 이루어진 환경을 구성했던 적이 있다.당시, Nginx에 SSL/TLS를 설정하고 모든 요청을 Nginx로 받아들여서 처리하도록 구성했었다.이때의 Nginx는 리버스 프록시로써 웹 서버로 들어오는 요청을 포트에 따라 구분하고,AWS EC2 내부 네트워크와 외부 네트워크를 보안적으로 분리하는 역할을 맡았다.( 요청을 포트에 따라 구분하는건 로드밸런싱과는 다른 개념이다. 트래픽 라우팅 이라는 표현이 좀 더 적합하다 )사용자가 보내는 모든 요청은 Nginx를 거치게되고, 그 과정에서 Spring 내부의 SSL/TLS는 설정하지 않아도 무방했다. 또 다른 예시로, 디자인 패턴상의 프록시인 Filter/Interceptor/AOP 가 있다.이 3가지는 모두 실제 요청 처리 중간에서 추가적인 작업을 하는 용도로 사용된다.Filter의 경우, WAS(or Tomcat -&gt; Spring)로 진입하는 요청을 가로채기 때문에 서비스 내에서의 문자 인코딩 호환이나 보안 쪽과 관련된 작업을 수행한다.Interceptor의 경우, 이미 보안 작업은 이뤄졌기 떄문에 보통 서비스 인증, 인가와 같이 내부 자원에 접근할 수 있는지와 관련된 작업을 수행한다.마지막으로 AOP의 경우, Spring 에서 동작하는 개념으로로그를 찍거나, 관련 있는 비즈니스적 기능들을 묶어 공통적으로 처리해야하는 작업을 수행한다.추가적인 내용으로, 애플리케이션 수준에서는 동적 프록시와 정적 프록시가 구분된다.동적/정적 이라는 표현은 보통 런타임 시에 결정되는지 여부에 따라 명칭이 정해진다.즉, 동적 프록시는 런타임 시에 프록시가 생성된다는 의미이며, 정적 프록시는 컴파일 시점에 프록시가 된다.동적 프록시의 예시로 Spring AOP를 생각할 수 있다.AOP 클래스에서 프록시 동작을 작성하고 나면, 실제 Proxy 객채의 생성은 런타임에 이뤄지기 때문이다. AOP 동적 프록시는 Java의 동적 프록시와 CGLib 프록시가 사용된다.관련해서 OOOService, OOOServiceImpl 의 형태로 서비스 객체를 인터페이스와 클래스로 구분하는 이유를 고민해볼만 하다.AOP는 기본적으로 대상이 implements 하는 인터페이스가 존재한다면 JDK 동적 프록시를 사용한다.반면, 인터페이스가 존재하지 않는다면 CGLib 프록시를 사용한다.여기서 성능적인 고려사항이 들어가는데,JDK 동적 프록시는 Reflection을 이용해 인터페이스 기반으로 프록시 객체를 생성한다.반면, CGLib은 바이트코드 조작을 이용해 클래스 기반으로 프록시 객체를 생성한다. 즉, Java 애플리케이션 빌드가 완료된 시점에서 바이트코드 조작은 이미 프록시가 생성되어 있고,리플렉션은 런타임 시에 필요에 따라 클래스가 생성된다.일반적으로 리플랙션은 매번 메타데이터를 바탕으로 메서드를 처리하기에 바이트코드 조작보다 성능이 떨어진다고 소개된다.그러나 JIT 컴파일러 등으로 인해 실질적인 성능차이는 크지않다. 인터페이스를 이용하면 유지보수의 유연함과 테스트 작성의용이함, 높은 확장성 등의 장점을 가져갈 수 있으므로 해당 구조를 이용하는게 주류를 이루고있다.덧붙이자면 CGLib의 경우, 프록시 객체생성을 위해 상속을 이용해야 하므로 상속이 불가능한 불변 클래스나 다중상속이 필요한경우에 사용이 어렵다는 단점도 있다.","aliases":[],"inlineTags":[],"frontmatterTags":["#excalidraw"],"headers":[],"links":[],"author":"","coverImageURL":"","fullURL":"공부/프록시.html","pathToRoot":"..","attachments":[],"createdTime":1739679671613,"modifiedTime":1748237155304,"sourceSize":23991,"sourcePath":"공부/프록시.md","exportPath":"공부/프록시.html","showInTree":true,"treeOrder":7,"backlinks":[],"type":"excalidraw"},"공부/헥사고날-아키텍처.html":{"title":"헥사고날 아키텍처","icon":"","description":"\n<a data-tooltip-position=\"top\" aria-label=\"소프트웨어 아키텍처\" data-href=\"#소프트웨어 아키텍처\" href=\"공부/헥사고날-아키텍처.html#소프트웨어_아키텍처_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">소프트웨어 아키텍처</a> <br><a data-tooltip-position=\"top\" aria-label=\"3-Tier 아키텍처\" data-href=\"#3-Tier 아키텍처\" href=\"공부/헥사고날-아키텍처.html#3-Tier_아키텍처_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">3-Tier 아키텍처</a>\n<br><a data-tooltip-position=\"top\" aria-label=\"헥사고날 아키텍처\" data-href=\"#헥사고날 아키텍처\" href=\"공부/헥사고날-아키텍처.html#헥사고날_아키텍처_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">헥사고날 아키텍처</a> <br><a data-tooltip-position=\"top\" aria-label=\"클린 아키텍처\" data-href=\"#클린 아키텍처\" href=\"공부/헥사고날-아키텍처.html#클린_아키텍처_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">클린 아키텍처</a>\n<br><a data-tooltip-position=\"top\" aria-label=\"포트와 어댑터\" data-href=\"#포트와 어댑터\" href=\"공부/헥사고날-아키텍처.html#포트와_어댑터_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">포트와 어댑터</a> <br><a data-tooltip-position=\"top\" aria-label=\"MSA\" data-href=\"#MSA\" href=\"공부/헥사고날-아키텍처.html#MSA_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">MSA</a> <br><a data-tooltip-position=\"top\" aria-label=\"참고\" data-href=\"#참고\" href=\"공부/헥사고날-아키텍처.html#참고_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">참고</a>\n본인은 Spring으로 웹개발을 배웠고, 지금까지 3회의 프로젝트 경험을 가지고 있다. 그 경험속에서 모든 아키텍처는 3-Tier 아키텍처였고, 프로젝트 규모도 작았기때문에 별다른 문제점을 느끼지는 못했었다. MSA라는 용어가 주변에서 자주 들려왔지만, 소규모 프로젝트에서는 고려할만한 대상이 아니라는 말도 함께 들려왔기에 크게 의식하지 않았었다.취업준비를 이어가면서 공고들과 채용설명회를 참가하다보니 우연히 헥사고날 아키텍처라는 용어가 눈에 띄었다. 조직내에서 헥사고날 아키텍처를 사용한다고 했고, 그 조직에 들어가고 싶었기 때문에 자연스럽게 아키텍처에 대해 공부하게 되어 글로 작성해본다.\n개념적인 이해를 돕기위한 글이라 자세한 내용은 없다\n하나의 서비스를 구성하는 요소는 다양하다. 일반 사용자가 엑세스 할 수 있는 UI 등을 제공하는 표현 계층\n비즈니스 로직이 처리되는 비즈니스 로직 계층\n서비스에 필요한 데이터들을 저장하고, 관리하는 데이터 계층\n서비스는 이러한 계층들이 유기적으로 얽혀있는 구조를 띄고있다.\n소프트웨어 아키텍처는 이 계층간의 구조와 관계를 나타내는 지침이나 원칙을 의미한다.3-Tier 아키텍처는 표현 계층, 비즈니스 로직 계층, 데이터 계층이 선형적으로 연결되어 있는 구조를 의미한다. 계층과 게층이 직접적으로 연결되므로 모놀리식 아키텍처의 한 종류라고 볼 수 있다.\n<br><img src=\"공부/이미지/3-tier-아키텍처.png\" target=\"_self\">서비스 이용자는 표현 계층을 통해 서비스에 접근하게되고, 어떠한 작업을 실행하면 비즈니스 로직 계층으로 요청이 전달된다. 이후, 데이터 요청이 필요한 작업이라면 데이터 계층를 통해 데이터를 얻어온 뒤 다시 표현계층에 처리된 결과를 출력하는 형식이다.이 구조에서 비즈니스 로직 계층이 사라지면 2-Tier 아키텍처, 데이터 계층까지 사라지면 1-Tier 아키텍처가 된다.\n이 구조에서 아쉬운 점은 각 계층간 종속성을 가지기 쉽다는 것이다.\n예를들어, Spring 프로젝트를 만들었다고 생각해보자.\nJPA를 사용한다고 가정했을 때, Service는 Repository에 대한 종속성을 가진다. Entity는 DB 테이블 규격과 JPA 문법에 맞춰지기 때문에 불필요한 기본생성자를 작성해야한다. 또한, 데이터 계층의 세부사항들이 노출되는 문제도 있다. 헥사고날 아키텍처는 애플리케이션의 코어 비즈니스 로직을 외부의 요청과 독립적으로 유지할 수 있는 아키텍처다. <br><img alt=\"1-hexagonal-architecture\" src=\"공부/이미지/1-hexagonal-architecture.png\" target=\"_self\">헥사고날 아키텍처는 크게 3가지의 구성요소로 이루어져 있다.\n프라이머리 어댑터(driving adapter) : 외부 요청을 받아들이고 코어 컴포넌트를 호출\n코어 컴포넌트(application core) : 비즈니스 로직을 처리하며, 세컨더리 어댑터를 통해 외부 시스템과 연동\n세컨더리 어댑터(driven adapter) : 외부 시스템과의 상호작용\n클린 아키텍처를 준수하기 때문에 저수준의 컴포넌트가 고수준 컴포넌트에 영향이 없도록 설계되어 있다. 이를 위해 포트와 어댑터를 이용한다\n헥사고날 아키텍처의 다른 이름은 포트와 어댑터 아키텍처다\n코드 레벨의 클린 코드나 지금 작성하는 클린 아키텍처 처럼 소프트웨어 개발에 클린이라는 용어가 들어갔을 때, 핵심은 추상화에 있다. OOP를 예로 든다면 각 코드들의 결합도는 줄이고 응집도를 높혀 독립적인 객체들로 구성하는 것이 클린하게 만드는 거라고 볼 수 있다.클린 아키텍처 또한, 아키텍처를 구성하는 각 계층들간의 결합도를 낮추고 응집도는 높히는 방식의 아키텍처 구성을 의미한다.Spring 기준으로, 일반적인 형태의 Service 클래스를 생각해보자@Service @RequiredArgsConstructor\npublic class UserServiceImpl implements UserService { private final UserRepository userRepository; @Override public UserResponseDto getUserInfo(Long userId) { // ... UserEntity user = userRepository.findById(userId); //... return UserResponseDto.fromEntity(user, userInfo); }\n}\n대략적인 형태만 생각해봤을 때, Service에서 Repository를 이용하여 Entity를 얻어내는 형태를 띈다. 이는 현재 코드가 작성된 비즈니스 로직 계층이 외부 시스템인 DB에 종속되기 때문에, DB테이블 구조가 변경되는 등의 변경에 직접적인 영향을 받게된다.헥사고날 아키텍처는 이러한 종속성을 제거하기 위해 어댑터 패턴을 이용한다.\n외부 시스템을 port로 구분하고, 각 시스템에 해당하는 어댑터클래스를 생성하여 비즈니스 로직에서는 일관된 처리방식을 제공한다. @Service @RequiredArgsConstructor\npublic class UserServiceImpl implements UserService { private final UserJpaPort userJpaPort; @Override public UserResponseDto getUserInfo(Long userId) { // ... User user = userJpaPort.findById(userId); //... return UserResponseDto.from(user); }\n}\n@Repository\n@RequiredArgsConstructor\npublic class UserJpaAdapter implements UserJpaPort { private final UserRepository userRepository; @Override public User getUserInfo(Long userId) { // ... UserEntity userEntity = userRepository.findById(userId); //... return User.fromJpaEntity(userEntity); }\n}\n이렇게 어댑터 패턴을 이용하여 외부 시스템을 호출하게 구성하면, 비즈니스 로직을 처리하는 곳에서는 항상 일관된 사용방식을 유지할 수 있다. 외부 시스템에 구조적인 변화가 있더라도 어댑터클래스만 수정해주면 되며,\n다른 외부 시스템을 호출하도록 변경하는 것도 포트만 변경해주면 되므로 수월하다.\n여기에 전략패턴까지 추가한다면 시스템 분류에따른 전략클래스를 생성하고, 전략 클래스내에서 관련있는 포트들을 관리하는 방식으로 작성할 수도 있을 것이다.\n마지막으로 MSA(Microservice Architecture) 에 대해서도 간단하게 살펴보자.\nMSA는 서비스 단위로 개발단위를 분류하여, 각 서비스들간의 유기적인 연결을 통해 아키텍처를 구성하는 방식이다. MSA또한 그 목적이 서비스간의 결합도를 낮추고 응집도를 높이는데 있다.모놀리식 아키텍처에서의 한 시스템은 메일, 검색 등의 여러 세부 서비스로 구분이 가능한데, MSA는 이러한 세부 서비스들을 각각 시스템으로 구성하는 것이다. 각 시스템이 제공하는 인터페이스를 통해 시스템간 통신으로 작업들을 처리한다.\n이러한 시스템간 통신에는 네트워크 통신이 필요하며, 그 과정에서 AMQP와 같은 여러 프로토콜들을 고려해야한다.\n헥사고날 아키텍처와 MSA의 관계를 생각해보자면\nMSA 구조내에서 각 서비스 시스템들의 내부구조에 헥사고날 아키텍처가 적용될 수 있다. MSA자체는 하나의 시스템을 여러 세부 시스템으로 나눔으로써 결합도를 낮춘다. 여기에 헥사고날 아키텍처를 적용하면 나눠진 각 시스템내의 결합도 또한 낮출 수 있게된다.\n<br><a data-tooltip-position=\"top\" aria-label=\"https://sunrise-min.tistory.com/entry/3-Tier-Architecture-%EC%A0%95%EC%9D%98-%EB%B0%8F-%EA%B5%AC%EC%84%B1%EB%B0%A9%EC%8B%9D\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://sunrise-min.tistory.com/entry/3-Tier-Architecture-%EC%A0%95%EC%9D%98-%EB%B0%8F-%EA%B5%AC%EC%84%B1%EB%B0%A9%EC%8B%9D\" target=\"_self\">3-Tier 아키텍처 정의 및 구성방식</a>\n<br><a data-tooltip-position=\"top\" aria-label=\"https://tech.kakaobank.com/posts/2311-hexagonal-architecture-in-messaging-hub/\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://tech.kakaobank.com/posts/2311-hexagonal-architecture-in-messaging-hub/\" target=\"_self\">유일한 멀티모듈 헥사고날 아키텍처 : 메시지 허브 적용기</a>\n<br><a data-tooltip-position=\"top\" aria-label=\"https://developers.hyundaimotorgroup.com/blog/381\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://developers.hyundaimotorgroup.com/blog/381\" target=\"_self\">클린 아키텍처 이론과 실습 #2 실습편</a>\n<br><a data-tooltip-position=\"top\" aria-label=\"https://engineering.linecorp.com/ko/blog/port-and-adapter-architecture\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://engineering.linecorp.com/ko/blog/port-and-adapter-architecture\" target=\"_self\">지속 가능한 소프트웨어 설계 패턴: 포트와 어댑터 아키텍처 적용하기</a>\n","aliases":[],"inlineTags":[],"frontmatterTags":["#서버"],"headers":[{"heading":"","level":1,"id":"_0"},{"heading":"소프트웨어 아키텍처","level":1,"id":"소프트웨어_아키텍처_0"},{"heading":"3-Tier 아키텍처","level":2,"id":"3-Tier_아키텍처_0"},{"heading":"헥사고날 아키텍처","level":2,"id":"헥사고날_아키텍처_0"},{"heading":"클린 아키텍처","level":3,"id":"클린_아키텍처_0"},{"heading":"포트와 어댑터","level":3,"id":"포트와_어댑터_0"},{"heading":"MSA","level":2,"id":"MSA_0"},{"heading":"참고","level":1,"id":"참고_0"}],"links":["공부/헥사고날-아키텍처.html#소프트웨어_아키텍처_0","공부/헥사고날-아키텍처.html#3-Tier_아키텍처_0","공부/헥사고날-아키텍처.html#헥사고날_아키텍처_0","공부/헥사고날-아키텍처.html#클린_아키텍처_0","공부/헥사고날-아키텍처.html#포트와_어댑터_0","공부/헥사고날-아키텍처.html#MSA_0","공부/헥사고날-아키텍처.html#참고_0"],"author":"","coverImageURL":"export/공부/이미지/3-tier-아키텍처.png","fullURL":"공부/헥사고날-아키텍처.html","pathToRoot":"..","attachments":["공부/이미지/3-tier-아키텍처.html","공부/이미지/1-hexagonal-architecture.html"],"createdTime":1738808938149,"modifiedTime":1743562737174,"sourceSize":8908,"sourcePath":"공부/헥사고날 아키텍처.md","exportPath":"공부/헥사고날-아키텍처.html","showInTree":true,"treeOrder":8,"backlinks":[],"type":"markdown"},"공부/be-아키텍처-기초.html":{"title":"BE 아키텍처 기초","icon":"","description":"가장 기본적인 웹 아키텍처의 경우, 브라우저를 통해 요청이 발생하면 DNS를 통해 IP를 특정,웹 서버로 요청이 이뤄진 다음 =&gt; 응답이 이뤄진다. 이 상태에서 데이터의 영속적인 저장을 필요로 하게되면 DB를 마련하는 흐름이 된다. 이후, 서버의 트래픽이 증가하면 서버 확장을 고려하게 된다.수직적 확장의 경우, 보통 비용문제나 한계가 존재하기 때문에 수평적 확장을 고려하게 되는데,이 경우에는 로드밸런서(Load Balancer)를 이용하여 트래픽을 고르게 분산하는 식으로 구성한다.서버와 마찬가지로 DB 사용량 증가로 인해 장애나 부하문제가 발생하게 된다면 DB 다중화를 고려할 수 있다. 보통 Master - Slave(Replica) 의 관계를 구성하게 되는데, Master에서는 원본 데이터 저장 및 쓰기 연산을, Slave(Replica)에서는 사본 데이터 저장 및 읽기 연산을 수행한다.만약, Slave(Replica)에서 장애가 발생한다면 Master에서 읽기 연산을 처리하며Master에서 장애가 발생하면 Slave(Replica) 중 하나가 Master가 되는 식으로 장애를 처리한다.이때, Slave(Replica)의 정보가 최신이 아닌 경우를 고려하여 Master를 여럿 두거나, 원형 다중화 방식을 고려할 수 있다.DB는 보조메모리를 활용하기 때문에, 처리 속도가 낮은 편에 속한다.반면, 주 메모리의 경우 한정적인 용량과 높은 비용을 가지지만 매우 높은 처리속도를 지닌다. 짧은 시간내에 반복적으로 조회되는 데이터의 경우에는 캐시 사용을 고려할 법 하다.DB 자원에 대한 접근 빈도를 줄임으로써 부하를 줄일 수도 있고, 작업 처리속도도 빠르기 때문이다.캐시를 도입하게 되면 데이터 접근 요청 발생 시, 우선적으로 캐시를 확인하고,캐시히트가 아닌 경우, DB에서 데이터를 가져온다. 또한, 그 과정에서 캐시에 데이터를 저장한다.만약, 캐시에 저장된 데이터가 쓰기명령에 의해 수정 및 변경된다면 캐시에 있는 데이터를 무효화(삭제) 하는 방식으로 캐시된 데이터의 일관성을 유지한다.캐시에 저장될 데이터는 갱신 빈도가 적고, 만료기간이 존재하는 휘발성 데이터가 적합하다.또한, 캐시가 가득차게 되는 경우에는 LRU, LFU, FIFO 등의 방식으로 데이터를 처리한다.웹 상에서의 정적인 컨텐츠(CSS, JS, 이미지 등)에 대해서도 캐시개념이 적용될 수 있으며, 이때 사용되는 캐시서버를 CDN(Content Delivery Network)이라고 부른다대략적인 웹 아키텍처 흐름초반에 웹 서버도 부하에 의해 수직적 or 수평적 확장을 고려하게 된다고 말했었다.이렇게 웹 서버가 여럿으로 분리되게 되면 웹 서버간의 상태정보 공유문제가 발생한다.웹 서버 각각이 상태정보를 지니게 되면, 사용자와 웹 서버간에 결합도가 증가하는 문제가 발생한다.이 경우에는 웹 서버가 무상태(stateless)를 유지하도록 구성하는 방법을 사용할 수 있다.즉, 웹 서버에서 상태 정보를 지니지않고 DB를 이용하여 여러 웹 서버들이 DB에서 상태정보를 얻어오도록 구성하는 것이다.이때 사용되는 DB(공유 저장소)의 종류는 RDBMS, Redis, NoSQL 등을 고려할 수 있다.서비스를 운영하다보면 나라 전체나 세계적인 규모로 확장될 수 있다.이렇게 되면 사용자와 서버간의 물리적인 거리문제가 발생하여 UX가 떨어질 수 있다. 이런 경우에는 데이터센터(Data Center)를 이용하여 각 지역별로 환경을 구축하게 된다.사용자가 요청을 보내면 GSLB를 통해 가장 가까운 데이터 센터로 요청을 이동시키는 것이다.이 방법에서의 고려사항은 데이터 센터간의 데이터를 동기화 시키는 것이다.이러한 분산 시스템 환경에서는 보통 메시지 큐(MQ)를 이용하여 각 데이터 센터들이 서로를 발행자이면서 구독자로 취급하도록 구성한다.한 DB에 저장된 데이터가 증가하면샤딩(수평적 확장)을 고려해야한다.적절한 샤딩 키 선정을 통해 특정 shard로요청이 집중되지 않게 조심해야한다.사용자ISP DNSGSLB 서버데이터 센터( 웹 서버 )IP 요청request데이터 센터IP 전달","aliases":[],"inlineTags":[],"frontmatterTags":["#excalidraw"],"headers":[],"links":[],"author":"","coverImageURL":"","fullURL":"공부/be-아키텍처-기초.html","pathToRoot":"..","attachments":[],"createdTime":1746260083837,"modifiedTime":1746601429021,"sourceSize":31270,"sourcePath":"공부/BE 아키텍처 기초.md","exportPath":"공부/be-아키텍처-기초.html","showInTree":true,"treeOrder":9,"backlinks":[],"type":"excalidraw"},"공부/cors,-xss,-csrf.html":{"title":"CORS, XSS, CSRF","icon":"","description":"CORS(Cross-Origin Resource Sharing)브라우저에는 SOP(Same Origin Policy) 라는 정책이 있다.Origin( 프로토콜 + IP + 포트 ) 이 동일한 서버에게서만 HTML, JS, CSS 등의 Web 자원들을 받아들이겠다는 정책이다.즉, 하나의 서버에게서만 자원을 얻어내겠다는 말이다.이는 UI용 FrontEnd와 API용 BackEnd로 구성된 서비스에서 문제가 된다.(Frontend와 BackEnd 의 Origin이 서로 다르기에 CORS라는 명칭의 오류가 발생한다.)CORS는 사실 사전설정을 통해 서로다른 Origin이라고 할지라도 자원공유가 가능하도록 하는정책을 의미한다. 이 CORS 관련 설정을 판단하는 주체는 브라우저다.브라우저에서 서버의 접근가능 host 목록을 요청하고, 현재 Origin이 그 목록에 존재하는지판단하는 형식이다.이때 접근가능 host 목록을 요청하는 요청을 Preflight(예비 요청) 라고 부른다.이 요청은 HTTP의 OPTIONS Method를 이용해서 실제 요청이 전달되기 이전에 host 목록을 받아온다. 만약, host 목록에 없는 Origin이라면 본 요청이 이뤄지지 않는다.( 매 요청마다 이뤄지지는 않고, 캐시를 통해 네트워크 비용을 관리한다 )Preflight 요청없이 바로 본 요청을 전송하는 방법도 있는데, 이 경우에는 서버측 자원보호를 위한 몇가지의 제약사항이 존재한다.XSS(Cross-Site Scripting)CSRF(Cross-Site Request Forgery)1. 요청의 메소드는 GET, HEAD, POST 중 하나여야 한다.2. Accept, Accept-Language, Content-Language, Content-Type, DPR, Downlink, Save-Data, Viewport-Width, Width 헤더일 경우에만 적용된다.3. Content-Type 헤더가 application/x-www-form-urlencoded, multipart/form-data, text/plain중 하나여야한다. 아닐 경우 예비 요청으로 동작된다.Credential(자격인증)이 필요한 경우에는 클라이언트와 서버 양측 모두 설정이 필요하다.이 경우, 클라이언트에서는 `credentials` 옵션으로 자신이 자격인증을 포함할 대상을 선택한다. ( same-origin / 모든 대상 / 모든 대상에게 X )자격인증 정보를 받아들일 서버에서는 Credentials 항목을 활성화 해야하며,받아들일 [Origin, HTTP Method, 헤더 종류]를 설정해야한다.CSRF는 보안공격 방식 중 하나로, 브라우저에 보관된 쿠키정보가 요청 시에 자동으로 포함되는 점을이용한 공격방식이다.이 공격에 관여하는 노드로는 [ 공격자, 클라이언트, 서버 ] 가 존재한다.시나리오 중 하나를 예시로 든다면,1. 클라이언트가 대상서버로 로그인( 브라우저에 쿠키 저장 )2. 공격자가 자신의 사이트로 클라이언트의 접근을 유도3. 공격자가 자신의 사이트에서 대상 서버로 요청( 이미 대상서버와의 쿠키정보가 있음 )4. 유효한 쿠키정보가 포함된 요청이므로, 대상서버가 정상응답이런 형식으로 공격이 이뤄진다.CSRF의 보안방법으로는 여러가지가 존재한다.우선, 공통적으로 POST, PUT, DELETE 같은 상태를 변화시키는 요청들과 그렇지 않은 요청들을 구분하여 정확하게 구현해야한다. 즉, GET 같은 요청은 정말 Read-Only로 동작하게 해야한다.1. CSRF토큰을 요청에 포함시키는 방법서버에서 요청들에 포함된 CSRF 토큰이 세션에 저장된 CSRF 토큰과 동일한지 검증하는 방법이다.즉, 모든 요청에 CSRF토큰이 포함되도록 하여 공격을 방어하는 방법이다.이 CSRF토큰은 브라우저에 의해 요청에 포함되어서는 안되며, 예측할 수 없는 안전한 값이어야 한다.또한, 이 방법은 HTML문서를 서버에서 생성해내야 한다.2. 쿠키에 SameSite 속성을 지정하는 방법서버에서 세션정보가 포함된 쿠키를 내려줄 때, Same-Site라는 속성을 추가하여 보내는 방법이다.이를통해, 이후 요청에서 동일한 출처인 경우에만 쿠키가 포함되도록 제한할 수 있다.인증정보를 얻어낸 출처가 아니라면 쿠키 정보가 포함되지 않도록 하는 설정이다설정에 따라 동일출처와 GET, HEAD, OPTION 같은 read-only 요청에 쿠키가 포함되도록 하거나,아예 동일 출처에서의 모든 요청에 쿠키가 포함되도록 할 수 있다.설명에서 볼 수 있듯이 Restful API를 지향한다면 서버에서 인증정보를 관리하지 않기때문에CSRF 공격위험이 줄어든다. 즉, JWT같은 토큰 인증방식을 선택한다면 서버에서 세션과 쿠키를관리하지 않으므로, 프론트엔드 측에서 토큰을 쿠키에 관리하지 않는이상 안전하다.XSS는 사이트 내에 악의적인 스크립트를 심어놓고, 랜더링하며 동작하게 하는 공격방법이다.악의적인 스크립트를 서버의 저장소에 저장시켜놓고, 일반 사용자가 해당 스크립트를 로드하는 과정에서 스크립트가 동작하게 한다.주요 공격방법으로는 크게 3가지 유형이 존재한다.1. 서버의 저장소에 스크립트를 저장하는 방법( Stored XSS )2. 서버에서 요청이 거부되었을 때, 반환된 페이지에서 스크립트가 동작하게 하는 방법(Reflected XSS )3. 브라우저의 DOM구조를 이용해 URL에 스크립트를 심어놓고 동작시키는 방법( DOM based XSS )XSS의 방어방법은 아래와 같다.1. 서버에서 스크립트 관련 문자를 필터링하여 거부하기2. 사용자 입력을 출력할 때, 특수문자를 이스케이프 처리( ex : &lt; 같은 문자를 동일한 표현의 안전한 &amp;lt; 로 변환 ) 3. CSP를 활용하여 특정한 출처에서만 JavaSciprt 파일을 실행하도록 제한4. httponly 옵션으로 활용해 JavaScript에서 쿠키에 접근할 수 없도록 제한5. secure 옵션으로 활용해 HTTPS 요청에서만 쿠키가 전송되도록 제한CSP(Content Secure Policy)CSP는 XSS 공격 완화를 위한 보안정책으로, Stored XSS 사례처럼 서버로부터 받은 정보를 브라우저가 신뢰한다는 점을 악용하는 점을 이용해올바른 스크립트를 지정하여, 해당 스크립트들만 동작하게 하는 정책이다.이를 적용하면, 브라우저에서 유효하다고 간주하는 서버로부터의 스크립트만 실행된다.","aliases":[],"inlineTags":[],"frontmatterTags":["#excalidraw"],"headers":[],"links":[],"author":"","coverImageURL":"","fullURL":"공부/cors,-xss,-csrf.html","pathToRoot":"..","attachments":[],"createdTime":1739416672948,"modifiedTime":1743829680381,"sourceSize":27789,"sourcePath":"공부/CORS, XSS, CSRF.md","exportPath":"공부/cors,-xss,-csrf.html","showInTree":true,"treeOrder":10,"backlinks":[],"type":"excalidraw"},"공부/java-기초.html":{"title":"Java 기초","icon":"","description":"Java는 대표적인 객체 지향 프로그래밍 언어로, JVM을 이용하여 OS나 하드웨어 환경에 제약받지 않는다는 특징을 가지고 있다.즉, JRE가 설치되어 있는 환경이라면 Java 프로그램을 실행할 수 있다는 의미다.Java로 작성된 코드는 컴파일을 통해 JVM이 해석할 수 있는 ByteCode로 변환되며, JVM의 인터프리터와 JIT 컴파일러에 의해 기계어로 변환된다.따라서, Java 개발자로서 JVM의 내부 구조나 동작 원리를 이해하는 것은 필수적이다.앞서 Java는 객체 지향 프로그래밍(OOP) 언어 라고 불렀는데, 이 OOP는 무엇인지에 대해 살펴보자OOP는 추상화를 통해, 구현하고자 하는 서비스를 객체단위로 나누어 구현하고 관리하는 패러다임을 뜻한다.즉, OOP로 작성된 서비스는 객체라는 단위를 지니고 있으며, 각각의 객체는 자신만의 상태와 동작를 보유하고 있다.개발자는 특정 객체로 범위를 한정지어 생각할 수 있으므로 유지보수에 용이하다는 장점을 지닌다.단, 처음부터 객체단위로 생각하여 서비스를 기획해야 하므로 초기 설계비용이 높은 편이다.OOP의 주요 특징으로는 [ 캡슐화, 상속, 추상화, 다형성 ] 이 있다.캡슐화 =&gt; 객체 외부에서의 접근 권한을 관리함으로써, 객체가 목적에 맞게 사용될 수 있도록 하는 특징상속 =&gt; 비슷한 유형의 다른 객체에서 기존 객체의 상태나 동작을 재사용함으로써 코드의 중복을 줄일 수 있는 특징추상화 =&gt; 서비스 혹은 사물의 특징을 파악하여 개념적으로 다루는 관점적인 특징다형성 =&gt; 비슷한 혹은 동일한 형태의 동작이더라도, 객체에 따라 세부동작을 다르게 수행할 수 있도록 하는 특징 이러한 특징 외에도, Java 개발자들 사이에서 중요하게 생각되는 5가지의 원칙(SOLID)이 있다.궁극적인 목표는 결합도를 낮추고, 응집도를 높임으로써 유지보수성과 확장성이 높은 코드를 작성하는 것이다.- S(단일 책임 원칙) =&gt; 하나의 클래스에 한 가지의 책임(기능)을 부여하라는 원칙이다. 최소한의 기능단위로 클래스를 설계하라는 의미이기도 하다.- O(개방 폐쇄 원칙)=&gt; 클래스나 모듈 등의 기존 코드에 대한 수정없이 확장이 가능하도록 설계하라는 원칙이다.- L(리스코프 치환 원칙)=&gt; 자식 클래스가 부모 클래스의 동작을 수행할 수 있어야 한다는 원칙이다.- I(인터페이스 분리 원칙)=&gt; 목적성에 맞도록 인터페이스를 잘게 분리해야한다는 원칙이다. 인터페이스를 최소한의 기능단위로 설계하라는 의미다.- D(의존 역전 원칙)=&gt; 특정 대상을 의존해야하는 상황이라면 가능한 인터페이스나 상위 클래스를 참조하라는 원칙이다..java(Java 코드).class(바이트 코드)기계어Java 개요기초적인 자료형 설명Java의 데이터 타입은 크게 기본형과 참조형으로 나뉜다.기본형은 선언된 Scope의 메모리 공간을 그대로 차지하며,참조형은 Heap 영역의 메모리 공간을 차지하되, 참조를 통해 Thread에서 간접적으로 사용하는 데이터 타입이다.참조형 데이터 타입은 복사 시에 1. 얕은 복사를 통해 메모리 참조 값을 복사해야 하는지,2. 깊은 복사를 통해 메모리에 저장된 실제 데이터를 복사해야 하는지 잘 판단해야 한다.기본형 데이터 타입은 알파벳 소문자로 시작하는 데이터(int, long, char 등) 들을 의미한다.참조형 데이터 타입은 알파벳 대문자로 시작하는 데이터(String, 클래스 타입) 혹은 배열과 같은 데이터를 의미한다.Java는 JVM이 메모리를 대신 관리해주므로,참조형이라도 JVM 메모리 주소 값을 관리하지 실제 메모리값을 관리하지 않는 Call By Value의 특성을 가진다.클래스 유형Java의 클래스는 OOP의 객체를 표현하는 수단이라고 볼 수 있다.클래스는 상태를 의미하는 Field와 동작을 의미하는 Method로 구분되며, 클래스를 바탕으로 생성된 객체는 인스턴스라고 불린다. 이 인스턴스는 Heap 영역에 저장된다.클래스는 키워드 조합이나 선언 위치, 특성에 따라 여러가지의 파생형이 존재한다.예를들어, 클래스 선언에 final 키워드를 붙히면 상속이 불가능한 불변 클래스가 된다.그 중에서도 상속 전용의 목적을 지닌 클래스를 추상 클래스라고 부르며, abstract 키워드를 붙혀 선언할 수 있다.추상 클래스는 일반적인 필드와 메서드 외에도 동작을 작성하지 않는 추상 메서드를 지닐 수 있다.추상 메서드는 이를 상속하는 자식 클래스에게 구현을 강제시킬 수 있다는 특징을 지니고 있다.여기서 또, 추상 클래스와 유사하지만 모든 메서드가 추상메서드로 이루어진 클래스는 인터페이스로 분류된다.인터페이스는 `interface`라는 고유 명칭으로 선언할 수 있다.인터페이스는 추상 클래스와 다르게 상수를 제외한 상태(필드)를 가질 수 없으며, 다중 상속을 지원한다.인터페이스를 상속하는 경우에는 `implements`라는 키워드를 사용하여 `구현한다`라고 표현한다.Java8 이후의 버전에서는 인터페이스도 추상 메서드 외에 `default`, `static` 메서드를 가질 수 있다.static, finalstatic과 final은 클래스에 국한되지 않은 키워드다.static은 선언된 대상이 저장될 메모리 공간을 Method 영역으로 한정짓는 역할을 한다.즉, 클래스 필드가 static으로 선언되었다면 인스턴스를 생성하지 않아도 사용이 가능하다.final은 불변의 의미를 지닌다.즉, 상수 선언이나 수정이 불가능한 인스턴스 생성에사용된다.이 외에도, 클래스 내부에 존재하는 클래스는 inner class 라고 부른다.클래스 설계 목적에 따라서는 팩토리 메서드 패턴을 구현한 팩토리 클래스나, 빌더 패턴을 구현한 Builder 클래스도존재한다.또한, 상수관리를 위한 전용 클래스로 Enum 이라는 열거타입이 존재한다.이는 생성자가 private인 final 클래스와 동일한 특성을 지닌다. 즉, 상속이 불가능하며 외부에서의 인스턴스 생성도 불가능 하다.클래스의 로딩순서기본적으로 클래스의 내용은 실제 사용시점에 로드된다.다만, 상수의 경우에는 Method 영역의 상수 풀에서 따로 관리되므로 직접적인 사용없이도 메모리에 로드된다.inner 클래스의 경우, static 선언이 되지 않은 경우에는 외부 클래스의 내용이함께 로드된다. ( static inner class인 경우에는 내부 클래스만 따로 로드시킨다 )싱글톤 패턴에는 이를 이용하여 static holder 라는 방법을 사용하기도 한다.인스턴스의 동기화와 메모리 누수문제를 해결하기 위해서 static inner class에외부 클래스 인스턴스를 static final 형태로 선언하는 방식이다.이렇게 되면 정적 내부 클래스를 통해 실제 인스턴스에 접근하기 이전까지는메모리에 로드되지 않기 때문에, 메모리를 알뜰하게 사용할 수 있다.( non-static inner 클래스는 외부 클래스의 인스턴스가 존재해야 하므로 불가 ) 클래스 내부의 요소들은 정적 변수 -&gt; 정적 블록 -&gt; 생성자 순으로 초기화된다.이 초기화는 첫 호출에서 한번만 호출되므로, Thread Safe 하다.","aliases":[],"inlineTags":[],"frontmatterTags":["#excalidraw"],"headers":[],"links":[],"author":"","coverImageURL":"","fullURL":"공부/java-기초.html","pathToRoot":"..","attachments":[],"createdTime":1740714236446,"modifiedTime":1743829227285,"sourceSize":32778,"sourcePath":"공부/Java 기초.md","exportPath":"공부/java-기초.html","showInTree":true,"treeOrder":11,"backlinks":[],"type":"excalidraw"},"공부/jdk,-jre,-jvm.html":{"title":"JDK, JRE, JVM","icon":"","description":"KernelUserCPURAMHDD, SSD ....Java Byte Code ( .class ).JavaHeap 영역 관리- Method Area( 공유 자원 ) =&gt; 클래스의 정적 요소( method, 상수 )- Stack Area &amp; PC Register =&gt; Thread 메모리 및 실행흐름- Heap Area( 공유 자원 )=&gt; 런타임 시 메모리( ex : new OOO )전체 클래스파일에서 필요로 하는 일부만 로딩=&gt; 코드 접근에 의해 필요가 생길때마다 로딩H/WS/WOSNative( C/C++ )Class Loader이름을 알고 있는 특정 클래스에 대한 정의( Byte Stream )을 가져오는 역할- BootStrap Class Loader =&gt; JVM에서 라이브러리(rt.jar, tools.jar)로 취급되는 것들을 로드- PlatForm Class Loader =&gt; 클래스 라이브러리( java.util, java.io ... ) 로드- Application Class Loader =&gt; 응용 프로그램 수준의 클래스 로드.java =&gt; 컴파일 =&gt; .class ( Byte Code 뭉치 == Byte Stream )LoadingLinking : 검증 =&gt; 준비 =&gt; 해석Using : 초기화 =&gt; 사용UnloadingGCRuntime인터페이스가 맞춰져 있으면 프로그램 운영 중에 네트워크로 프로그램 코드를 수신할 수 있음JVM명세가 정하는 규칙과 제약사항을 확인( 파일 형식, Metadata, ByteCode, Symbol 참조( 클래스 참조구조 등 ) )ByteCode 수준에서 OS 수준의 API 호출 등의 보안위협에 대한 검증도 포함Linking검증준비 및 해석객체 인스턴스가 저장될 메모리 공간 확보 및 초기화생성자 호출하기 전의 상태( 필드 초기값은 생성자 호출과 함께 초기화 )상수 수준의 Symbol 참조를 직접 참조로 대체Java 객체 형태[ MetaData ]- 클래스 이름- Lock( 동기화 )- GC age- 해시코드- 상수, 정적 필드etc ...[ 필드 정보 ]- 필드 변수( 기본값 )- 배열, 참조타입 등headerpayloadRuntime AreaExecution Engine32bit app =&gt; 2^32 byte ( 약 1.728GB) 정도의 가상메모리 공간을 가짐Heap( 가장 큰 영역 )MethodStack( &gt;= 1 )가상메모리- JIT 컴파일러가 번역한 기계어 코드의 캐싱을 위한 공간- Java 8 이후로 PermGen =&gt; Metaspace에 속함=&gt; JVM힙이 아닌, Native 메모리에서 관리 ( 동적으로 크기 변함 )[ Runtime Constant Pool ( 상수 관리 ) ]- 클래스의 메타정보, 런타임에 동적으로 상수추가 가능Method : 정적인 요소 ( 타입정보, Method, 상수, 정적 변수 등 )Heap : 인스턴스( Java 객체 )Garbage Collector- GC가 관리하는 메모리 영역으로 인스턴스, 배열이 저장되는 공간- 설정으로 크기변환이 가능하며, 부족하면 ( OutOfMemoryError 발생 )- 세대별 컬렉션 이론기반의 설계 및 운영( young(eden, survivor)/old gen .. ) Metaspace( 영구 )Old GenerationYoung Generationedens0s1참조가 사라진 개체가 GC대상이며, Minor, Major, Full GC로 구분- 각 GC 수행마다 STW가 발생 / ( Major는 Old Gen / Full은 Heap 전체 )Minor GC는 약 1초 정도 소요 / Major, Full GC는 n초 이상 소요( GC튜닝은 Full GC를 줄이거나 막는게 목표 )- GC는 영역 간 이동에서 발생=&gt; G1GC 이전에는 세대별 컬렉션 이론을 따르므로, Full GC 영향이 큼=&gt; G1GC 이후에는 고정된 Region 단위의 국지적인 GC 이므로 전체영향이 작음( 다만, G1GC도 각 영역들에서 일어나는 GC가 STW를 발생시킴 )Stack : Thread별 공간, 작업처리( 콜스택 등 )핵심 =&gt; 언제, 무엇을, 어떻게 회수할 것인가?- Method 호출에 따라 Stack Frame이 쌓이며, 지역변수의 생명주기 관리- Thread 마다 독립적인 공간이 관리Interpreter와 JIT CompilerByte Code를 읽으면서 기계어로 번역하고, 자주 사용되는 코드를 Method 영역에저장Tomcat, Netty 같은 Java EE 기반의 WAS들도 Java 프로그램이므로, JVM을 사용한다Java15 에서 정식으로 인정받은 최신 GC는 ZGCG1GC의 각 영역도 Eden, Survivor, Old 로 구분되는데,객체들이 위치하는 영역을 변환시키는 과정에서 STW가 발생함다만, 각 영역이 고정된 작은 크기를 지니기 때문에 GC 성능이 좋은 것.( Minor GC가 발생할 때, 조건에 따라 Old영역의 일부도 함께 GC하는 Mixed GC 진행 )그러나, 객체의 크기가 충분히 커지면 여러 연속된 영역들을 차지하게 되고, 이러한 객체들이 많아지면 결국 GC의 성능은 이전과 비슷하거나 더 낮아짐( 새로운 객체를 할당하기 위한 영역 탐색도 힘들어짐 )문제해결을 위해 ZGC에서는 가변길이의 ZPage라는 단위로 영역을 구분함ZPage는 크기 별로 small, medium, large 로 구분됨( 객체 크기에 맞게 Page 단위의 메모리를 할당할 수 있어짐 )각 Page에서 일어나는 GC들은 멀티스레드를 이용해서 애플리케이션 작업과동시에 일어나도록 구성되어 있으며, 진짜 필요한 순간에만 STW가 발생함즉, 애플리케이션 스레드와 함께 동작하는 스레드를 이용해서 동적으로 메모리 상태체크=&gt; 실제 STW과정에서는 Heap 영역의 탐색시간의 감소=&gt; Page 크기에 맞게 탐색이 이뤄지므로 효율성 증가=&gt; Page 단위의 메모리 재할당 및 압축으로 인해 효율성 증가=&gt; STW 시간 감소보통 GC에서 일어나는 과정은 3가지로 구분매 과정에서 STW(애플리케이션 동작 중지) 발생1. 현재 Heap 내의 객체상태 판단2. Garbage로 판단된 메모리 영역 초기화3. 살아남은 객체영역 재편성JDKJREJVMLibrariesjava.util.*;java.lang.*;java.io.*;등등..ClassLoaderRuntime AreaExecution 개발 도구Jar, War 등의 패키지로 만들기 위한도구들ex: javac, javadoc, javap..Java 프로그램을 실행하기 위해서는 JRE가 필요하다.JRE는 JVM를 포함하므로, JRE와 JVM은 별개의 프로세스가 아니다.JDK는 Java 프로그램 생성, 빌드, 배포 목적의 도구다.Java 프로그램은 일반적으로 빌드를 통해 바이트코드로 변환 및 실행된다.즉, Java 개발자라면 JDK 환경에서 개발을 진행하게 된다.빌드 및 실행된 프로그램은 패키징을 통해 Jar 또는 War가 된다jar 혹은 war 파일을 실행시키기 위해서는 JRE만 구성되어도 된다.이 외에 JavaEE나 JavaSE 등의 용어도 존재하는데,JavaEE는 Web 서비스를 제공을 목적으로하는 Java이며, Jakarta로 불린다.JavaSE는 범용적인 개발목적의 Java를 의미한다.컴파일IDEJDKJREByteCode =&gt; 기계어( 바이트 코드를 읽을 수 있는 S/W적 OS )Class Loader ( Loading =&gt; Linking =&gt; Initialization )Runtime AreaMethod Area / Heap Area / Stack Area PC Register, Native Method StackExecution EngineInterpreterJIT CompGCJNI,Natvie MethodInterfaceNative MethodLibraryJava Virtual Machine빌드도구JMM 관점에서는 JVM Main Memory와 Thread Working Memory로 구분된다.이땐, 스레드 작업에 의한 동기화에 초점을 맞춰 생각하는게 좋다.JVM 메인 메모리는 모든 스레드들이 서로 공유하는 공간=&gt; Heap 영역과 Method 영역에 해당되는 공간을 의미한다.Thread 작업 메모리는 각 스레드들에게 개별적으로 할당되는 공간=&gt; Stack 영역과 별개로 JVM 메인 메모리에서 인스턴스 변수나 클래스 변수를=&gt; 캐시해오는 메모리 공간을 의미한다.Stop-The-World(STW)GC가 수행되는 동안 애플리케이션의 모든 실행이 일시적으로 중단되는 현상Minor, Major, Full GC 모두 가리지않고 발생하며, 발생 시간의 차이만 존재한다.Method Area","aliases":[],"inlineTags":[],"frontmatterTags":["#excalidraw"],"headers":[],"links":[],"author":"","coverImageURL":"","fullURL":"공부/jdk,-jre,-jvm.html","pathToRoot":"..","attachments":[],"createdTime":1739174672088,"modifiedTime":1743744791875,"sourceSize":76847,"sourcePath":"공부/JDK, JRE, JVM.md","exportPath":"공부/jdk,-jre,-jvm.html","showInTree":true,"treeOrder":12,"backlinks":[],"type":"excalidraw"},"공부/json-web-token.html":{"title":"Json Web Token","icon":"","description":"Json Web TokenJWSignatureJWEncryptionJOSE HeaderPayloadSignature일반적으로 Web 개발 등에서 사용자 인증 목적으로 자주 사용하는 토큰signature를 제외하고 base64 디코딩을 통해 내용 확인가능=&gt; 따라서 신뢰할 수 있는 네트워크에서만 사용JSON 형태에서 각 속성들을 Claim 이라고 부르며,속성들의 Key는 Unique 해야한다암호화 방식에 따라 대칭과 비대칭으로 구분- 대칭키(key 1개)의 경우, HS 시리즈- 비대칭키(key 2개)의 경우, RS나 ES 시리즈signatrue 검증은 토큰의 header와 payload로 생성한 signatrue를토큰에 있던 signatrue와 비교하는 방식직렬화 방법에 따라 Unprotected Header 존재토큰 생성에 사용된 알고리즘 (JWA) 정보대칭 or 비대칭 방식에 따라 공개키 정보서명에 사용된 공개키 집합 정보ETC..Compact 직렬화일 경우, 아래 방식으로 signature 생성1. BASE64URL(UTF8(JWS Protected Header))2. BASE64URL(JWS Payload)3. 1과 2를 `.`을 사이에 두고 결합4. JWA를 이용해 3을 서명토큰의 실질적인 데이터발행자, 제목, 수신자, 만료기간, 유효기간, 발행기간식별자 ETC..사용자 임의의 값들을 등록할 수 있음토큰의 변조를 검증하기 위한 용도내용이 외부에 노출되지 않으며, 대칭 or 비대칭 방식에 따라 사용되는 키 유형이 다름을 주의해야 함🌐[[직렬화]]JWS Compact Serialization( 일반적으로 접하던 형태 )JWS JSON Serialization( 높은 가독성과 다중 서명 )Flattened JWS JSON Serialization=&gt; base64 인코딩된 header와 payload, 그리고 signatrue를 `.`으로 구분하여 이어붙힌 형태=&gt; JSON 형태로 payload, signatrues[ { protected, header, signature } ] 의 구조헤더가 Protected와 Unprotected로 구분되며, Unprotected는 인코딩 하지 않음=&gt; JWS JSON Serialization 에서 signatures 부분이 하나인 경우, 평면화하여 표현한 것네트워크 전송에는 Compact 방법이 제일 유리하며, JSON 직렬화는 가독성과 디버깅에 유효- JOSE Header - JWE Protected Header - JWE Shared Unprotected Header( JWE JSON Serialization를 사용하는 경우 ) - JWE Per-Recipient Unprotected Header( JWE JSON Serialization를 사용하는 경우 )- JWE Encrypted Key- JWE Initialization Vector- JWE Ciphertext- JWE Authentication Tag- JWE AAD( JWE JSON Serialization를 사용하는 경우 )총 6개의 파트로 구분되며, 모든 내용이 암호화 된다JWS와 동일하게 크게 Compact와 JSON 직렬화 방식이 존재모든 내용이 암호화되므로 신뢰할 수 없는 네트워크로 정보를 전달할 때 유용하다AuthenticationAuthorizationBASE64 인코딩=&gt; 6비트씩 끊어서 문자로 치환하는 방식의 인코딩원본 데이터보다 오히려 크기가 커지는 문제가 있지만데이터를 6비트라는 문자 범위로 제한시키므로이미지, 영상같은 비정형 데이터를 문자로 표현하기 위해 주로 사용되는 인코딩 방식","aliases":[],"inlineTags":[],"frontmatterTags":["#excalidraw"],"headers":[],"links":[],"author":"","coverImageURL":"","fullURL":"공부/json-web-token.html","pathToRoot":"..","attachments":[],"createdTime":1739186177754,"modifiedTime":1755086010939,"sourceSize":24365,"sourcePath":"공부/Json Web Token.md","exportPath":"공부/json-web-token.html","showInTree":true,"treeOrder":13,"backlinks":[],"type":"excalidraw"},"공부/network.html":{"title":"Network","icon":"","description":"OSI 7Layer( CLIENT )OSI 7Layer( SERVER )TCP Connection 수립, 해제과정SYNACK + SYNACK3-way handshake end3-way handshake startFINACKFINACK4-way handshake end4-way handshake startSSL/TLS인 경우 인증서 검증 및 키 교환SYN-SENTCLOSEDLISTENSYN-RECEIVEDESTABLISHEDESTABLISHEDFIN_WAIT_1CLOSE_WAITFIN_WAIT_2TIME_WAITLAST_ACKCLOSEDCLOSEDTIMEOUT!!1. FIN을 받고 2. TIME_WAIT 이후3. TIMEOUT =&gt; CLOSED특이하게도 Client에서 위 과정처럼 연결을 해제하는 모습을 볼 수 있다.이는 혹시모를 네트워크 상의 지연패킷을 대비하여 대기하는 의미,그리고 연결이 명확하게 닫혔는지 확인하기 위함이다.만약, TIME_WAIT 없이 연결을 종료해버리면 네트워크 이슈등의이유로 ACK을 못받았을 때, 서버는 LAST_ACK 상태를 유지하게 된다.이렇게 되면 다음 연결에서 클라이언트는 정상적으로 연결이 닫혔다고 생각하여3-way handshake를 시도하겠지만, 서버측에는 이전 연결이 남아있게 된다.이러한 경우들을 대비하기 위해 클라이언트는 바로 연결을 종료하지 않는다.대기상태에 있는 동안 서버에서 다시 FIN을 보내는 경우를 대비하는 것이다.OSI 7Layer( CLIENT )OSI 7Layer( SERVER )CLIENT HELLOSERVER HELLOSSL/TLS 수립과정서버가 보낸 인증서 검증 및 양측 값을 이용한 문자열 생성생성된 문자열 전달SSL/TLS 수립은 서버가 공인받은 안전한 사이트인지 검증하는 과정이다.클라이언트의 문자열 A와 서버측의 문자열 B, 그리고 서버의 pub key를 이용해안전한 서버인지 확인한 후, 클라이언트에서 서버의 A, B를 결합한 문자열을 생성하고 서버의 pub key로 암호화 하여 전달한다.( 서버의 private key는 노출되지 않았으므로 안전하다 )이렇게 되면 양측 모두 A, B를 결합한 문자열을 가지게 되며,A, B, 문자열 총 3개를 이용하여 공통의 Session key를 얻을 수 있다. 이 예시는 2번의 RTT를 가지는데,TLS 1.3 에서 1번의 RTT를 가지도록 과정을 단축했다.이 경우에는 CLIENT HELLO의 문자열 A로 서버에서 세션키를 미리 만든다.그리고, 서버의 인증서를 검증한 클라이언트도 SERVER HELLO의 문자열 B를 이용하여 세션키를 만든다. ( pre-master-secret 라는 용어&amp;개념이 사라짐 )랜덤 문자열 A + 암호화 방식랜덤 문자열 B + 인증서( pubkey )마지막 패킷을 이용한 연결 종료패킷 송수신과정에서 수신측의 TCP Buffer 용량이 부족한 경우,송신측에서는 해당 용량이 비워질 때까지 기다린다. ( 이 정보는 ACK을 통해 알림 )즉, 수신측의 TCP Buffer가 비워지는 속도가 파일 송수신 속도에영향을 끼친다네트워크 다운로드 속도가 느리다면 점검해봐야 한다!!TCP 연결이란 무엇인가?- 기밀성 x ( 암호화 x )- 무결성 x ( 상대방을 인지 x )보안성이 없는 상대와 서로 정보를송수신 할 수 있는지 확인하고, 관련정보를 교환하는 과정RTT테스트 패킷을 이용한 연결 가능확인 세그먼트 크기, sequence 번호 등 공유URL vs URI vs URN순서대로 [ 위치, 식별자, 이름 ] 이라는 차이가 존재한다.URL은 해당 자원 위치로 가기 위한 방법을 포함한 값이고,URI는 해당 자원을 식별할 수 있는 값 URN은 해당 자원 이름을 나타내는 값이다.URL의 예시는 https://naver.comURI의 예시는 naver.com 또는 https://naver.comURN의 예시는 보통 urn:isbn:0-486-27557-4 이런 형식으로 나타낸다( isbn이 0-486-27557-4 번인 자원을 나타내는 URN )urn 형식으로 표기하는 경우에만 urn 이다GSLB와 CDNISP와 DNS서버를 이용해 목적지의 IP를 알아내는 방식은 DNS서버에서 네트워크 분산을 지원하지 않으므로 트래픽이 한 서버로 몰릴 수 있다.서비스 규모가 커지는 경우, 관련하여 GSLB와 CDN이라는 개념이 등장한다.1. GSLB는 네트워크 트래픽 자체를 분산시켜서 가장 적절한 서버로 요청을 전송하는 것2. CDN은 캐시서버를 이용해 원본 서버에 접근하기 전에 캐시된 내용을 전달함으로써 빠른 응답을 제공하는 것을 의미한다. 이때 CDN에는 PoP( Points of Presence ) 서버라는 개념이 등장하며, 요청자 네트워크와 목적지 네트워크가 만나는 가장 가까운 지점을 의미한다. PoP서버는 아키텍처 구현에 따라 Push/Pull 중 하나, 그리고 분산형/통합형 중 하나를 선택할 수 있다.Push/Pull은 어떻게 원래서버의 내용을 동기화할 것이냐를 결정짓고, 분산/통합은 어떤 방식으로 PoP 서버를 구성할 것이냐를 결정짓는다.failover?GSLB로 연결된 서버에서 장애가 발생하면사용자는 다른 서버로 연결되어야 한다.GSLB에서는 서버 상태를 체크하는 기능이 존재하기 때문에 무중단배포 형식으로 요청을다른 서버로 분산할 수 있다.Client Hello와 Server Hello에서 문자열은 암호화 되는가?암호화가 되려면 양쪽에서 복호화할 수 있는 수단이 있어야 한다즉, 양쪽이 각자의 공개키를 서로 공유하면 암호화된 문자를 안전하게 전달할 수 있다.pubKey를 암호화 전용 / privKey를 복호화 전용으로 쓰면 안전HTTP 변천사HTTP는 HyperText 를 전송하기 위한 규약체계로, HTML/JS/CSS 같은 문서들을 웹 상에서 송수신하는데 사용되며, L7(응용 프로그램) 계층에서 동작한다.HTTP는 두 노드간의 데이터 전달을 주 목적으로 하기때문에 데이터가 정상적으로 전달되었는지를 판단하지 않는다. 따라서, 기본적으로 신뢰성 없는 데이터 전송규약이다.데이터 송신자를 수신 측에서 특정할 수 없다 ( 무상태성 )이러한 특징은 네트워크 상에서 데이터 손실이나 인증관리 측면에서 여러가지 영향이 있었고,L4(전송) 계층의 TCP/UDP 프로토콜 위에서 동작함으로써 단점을 보완한다.초기 HTTP는 0.9 버전으로, 이 버전의 경우 오늘 날에 사용되지 않으므로 생략한다[ HTTP/1.0의 특징 ]- Header 개념에 의한 다양한 Method(POST, PUT, DELETE)와 문서 Content-Type 지원- 상태코드의 추가이 버전에서는 매 요청-응답마다 새로운 TCP 연결을 구성해야하므로, RTT 압박이 크다.실질적으로 살펴볼만한 버전은 1.1 버전 부터다.[ HTTP/1.1의 특징 ]- keep-alive 라는 TCP 연결 유지기능- 파이프라이닝 ( 연속적인 request )- host Header 추가로 인한 동일 IP에서의 여러 도메인 운영- proxy 서버를 통한 client 인증 header 추가의 기능이 추가되었다.L7 계층인 HTTP 수준에서 L4 계층의 연결을 관리할 수 있는 기능이 추가되었다.이 버전에서는 파이프라이닝을 통해 비동기적인 요청이 가능했지만, 처음 보낸 요청을 서버가 응답하기 전에는 다음 요청이 처리되지 않는 HOLB 현상이 있었다.( 연결 유지를 통해 연속적으로 요청을 보낼 수 있었지만, 응답은 순서대로 이뤄졌다 )[ HTTP/2.0의 특징 ]- 바이너리 프레임과 멀티플렉싱- 서버 푸시- 중복되는 헤더의 압축을 통한 reqeust 용량 감소2.0 버전에서는 1.1 버전의 HOLB 문제를 해결했다.헤더를 프레임 단위로 쪼개서 각 요청 packet의 크기를 줄이고, 이를 병렬적으로 받아들이면서가장 처리가 빠른 요청부터 처리하도록 개선되었다. ( TCP 수준의 연결관리는 여전히 FIFO를 따르기 때문에 TCP의 HOLB는 여전히 존재했다 )또한, 서버푸시 기능을 통해 서버측에서 응답에 필요한 자료목록을 파악해놓고,추가자료를 요청받지 않아도 함께 보내는 식으로 성능을 향상시켰다.TCP는 패킷을 순차적으로 받아서 처리하는데, 앞선 패킷에 문제가 생기면 다음 패킷을 못보내는 문제는 여전했다즉, 요청 간의 HOLB는 사라졌지만한 요청 내에서의 HOLB는 여전하다는 뜻HTTP Method는 크게 쓰기와 읽기로 구분된다.[ 읽기 ]- GET =&gt; 자원 조회- HEAD =&gt; 자원의 헤더만 확인- OPTIONS =&gt; 요청하려는 자원이 지원하는 Method 확인[ 쓰기 ]- POST =&gt; 신규 자원의 추가- PUT =&gt; 기존 자원의 수정- PATCH =&gt; 기존 자원의 부분적 수정- DELETE =&gt; 자원의 삭제PUT과 PATCH가 유사한데, 아래의 차이가 있다.PUT은 기존 자원의 모든 내용을 제거하고 주어진 부분 작성PATCH는 기존 자원의 나머지 부분은 보존하고 주어진 부분 수정HTTP 상태코드는 크게 1xx 부터 5xx 까지 5가지로 분류된다.- 1xx ( 정보 응답 )- 2xx( 성공적인 요청 )- 3xx( redirect )- 4xx( 클라이언트 오류 )- 5xx( 서버 오류 )주요 코드로는 아래 종류가 있다.- 100( 요청이 이어져도 됨 )- 101( 프로토콜 전환 )- 200( 요청 성공 )- 201( POST, PUT을 통한 성공적인 자원 생성 )- 202( 요청이 성공했으나, 처리 중 )- 204( 요청은 정상이나, 응답은 비어있음( ex: DELETE ) )- 301( 영구적인 Redirect )- 302( 일시적인 Redirect )- 304( 캐시된 데이터의 사용 )- 400( 부적절한 요청 데이터 )- 401( 잘못된 인증 정보 )- 403( 권한에 없는 자원 요청 )- 404( 잘못된 자원 요청 )- 405( 지원하지 않는 요청 Method )- 500( 알수없는 서버 에러 )- 501( 서버에서 지원하지 않음 )- 502( 서버가 다른 서버에서 잘못된 응답을 받음 )- 503( 서버 혼잡 )- 504( 서버가 다른 서버에 대한 응답대기 시간 초과 )- 505( 지원하지 않는 HTTP 버전 )HTTPS 는 HTTP 요청/응답을 압축하여 보낼 지 설정할 수 있다.이렇게 압축된 요청/응답은 패킷의 크기와 수를 줄여주므로 효과적이지만, 이를 이용한 공격방식도 있다.CRIME과 BREACH 라는 공격이 존재하는데, 각각 요청과 응답을 대상으로한 공격방법이다.전체적인 아이디어는 요청/응답을 압축한다는 점에 집중해서 동일한 문자가 포함되는 경우, 압축률이 변화한다는 점을 노린다.CRIME의 경우, 보내는 문자를 지속적으로 변화시키며 압축률이 줄어들 때마다 특정 문자가 보안정보에 속한다는 사실을 알아낼 수 있다.BREACH의 경우, CRIME과 동일하지만 응답에 초점을 맞춘 공격방법이다.요청 값이 응답에 포함되는 요청들을 대상으로 CSRF 토큰과 같은 주요토큰들을 탈취하는데 사용된다.방어방법으로는 TLS 압축을 비활성화 하는 방법, 그리고 매번 보안값을 변경하는 방법,또는 보안값을 암호화하는 방법 등이 있다.이벤트 기반 아키텍처(Event Driven Architecture, EDA)Event 라는 용어는 프로세스 외부 동작에 의해 발현되는 신호, 혹은 상태변화 정도로 받아들일 수 있다.사용자의 키보드 입력이라는 이벤트에 의해 H/W에서 Driver를 거쳐 프로세스에 도달하고, 실제로 입력된 내용이 출력되는 식으로 말이다.이벤트의 특징은 발현되기 이전까지는 프로세스에서 감지할 수 없다는 점, 그리고 언제 발현될지 가늠할 수 없다는 점이 있다.따라서, 기본적으로 이벤트는 비동기적이며 이벤트 발생에 대한 처리방식( Handler, Listener )를 필요로 한다.MSA에서 이런 이벤트 기반의 아키텍처를 쉽게 접할 수 있는데, EDA로 구성된 MSA를 Event Driven MicroService 라고 부른다.분산된 여러 시스템 간에 정보를 공유하고, 동기화하기 위한 수단으로 이벤트를 이용하는 것이다.흔히 웹 서비스에서 이뤄지는 Request 도 이벤트의 한 종류라고 볼 수 있다.백엔드 서버입장에서 사용자가 언제 요청을 보낼지 가늠할 수 없으며, 각 요청들은 독립적으로 동작하기 때문이다.따라서, 이벤트 기반의 환경구성은 보통 이러한 요청/응답의 구조로 정보공유와 동기화가 이뤄진다.( 항상 비동기적으로 동작한다는 점이 웹 요청과의 차이점이다 / REST 요청은 기본적으로 동기적이기 때문 )여기까지 와서, 이벤트 기반 동작방식의 고려사항은 무엇일까?다수의 시스템으로 구성된 MSA 환경이라고 생각해보자.여러 시스템에서 한 서비스로 이벤트를 발생시킬 경우에 임계영역에 동시접근하는 문제가 생길 수 있다.서비스 내에서 동시성 관리를 통해 문제를 해결할 수도 있겠지만, 요청만큼 Thread가 증가하고 서비스 부담이 증가할 것이다.뿐만아니라, 이벤트에는 발생순서가 존재할텐데 동시에 한 서비스에서 처리하면 순서를 관리하는 비용도 추가된다.이런 상황에서, 이벤트 메시지 자체를 관리해주는 중앙관리 시스템의 필요성을 느끼게 된다.이를 해결하기 위해 사용되는 시스템이 메시지 큐(Message Queue) 다.메시지 큐는 AMQP 기반으로 동작하며, 여러 시스템에서 온 메시지를 Queue의 형태로 관리한다.Queue에서 반환되는 메시지들은 특정한 Topic을 지니고 있으며, 이를 구독(Subscribe) 하는 시스템들에게 알림을 보내면 해당 시스템에서 메시지를 받아 처리한다. 메시지 큐를 사용하는 서비스는 발행(Publish)과 구독(Subscribe)으로 분류된다.발행(Publish)은 메시지를 큐에 저장시키는 서비스를 의미하며, 구독(Subscribe)은 큐에서 메시지를 받아 처리하는 서비스를 의미한다.Queue 구조의 특징 상, 메시지의 발생순서와 처리순서를 맞추기 쉬우며 서비스에 순간적으로 많은 트래픽이 몰리는 현상을 방지할 수 있다.( 이 외에도 직접적으로 다른 서비스를 호출하는게 아니기 때문에 서버간 결합도를 줄일 수 있으며, 쉽게 확장도 가능하다 )다만, 메시지 큐 서버를 여러 서비스가 함께 사용하는 상황에서 메시지 큐 시스템에 장애가 발생하면 관련 서비스들에 영향을 끼치는 문제가 발생할 수 있다.이와 관련하여 메시지 큐 서비스는 보통 로그를 통해 메시지를 영속화하는 기능을 제공하며, 과거 메시지나 유실된 메시지를 관리하는 Queue(DLQ)를 별도로 관리한다.또한, 클러스터링을 통해 다수의 메시지 큐 서버를 구성하여 한 서버에 장애가 발생하더라도 영향을 줄이는 방식으로 아키텍처를 구성한다.메시지 큐의 메시지를 보관, 관리하는 서비스를 Broker라고 부르는데, 주요 브로커(메시지 큐 서비스)로는 RabbitMQ나 Apache Kafka가 존재한다.조금 더 상세하게 분류하자면 Message Broker와 Evnet Broker로 구분할 수 있다.메시지 브로커는 메시지의 전달, 라우팅, 변환을 담당하는 시스템을 의미한다.( ex : RabbitMQ )이벤트 브로커는 EDA에서 사용되는 메시징 시스템으로, 이벤트(시스템 간 상태변화)의 전달과 라우팅을 중점으로 둔다. ( ex : Kafka )주요 차이점으로는 메시지(이벤트)의 사후관리가 있다. 메시지 브로커는 한번 소비된 메시지가 소멸하지만, 이벤트 브로커는 소멸하지 않는다.따라서, 과거 메시지 기록이 필요하지 않은 단발적인 메시지 ( ex : 알림 ) 같은 경우에는 메시지 브로커를 사용하는 것이 적절하다.반면, 과거 메시지 기록이 필요하고 상황에 따라 복구해야할 수도 있는 경우에는 이벤트 브로커를 사용하는 것이 적절한다.Redirect와 Forwardredirect는 재지시를 뜻하는 말이다.즉, 클라이언트의 방문위치가 잘못되었거나, 부적절하니 처리를 위한 올바른 URL로 재요청 하라는 뜻이다.redirect 명령은 클라이언트에게 3xx 응답코드를 내려주며, 브라우저는 해당 응답코드를 수신하면 서버의 응답에서 redirect url을 찾고, 해당 url로 새로운 요청을 보낸다.잊지 말아야하는 부분은 다시 클라이언트에게 응답이 이뤄진 다음, 클라이언트가 재요청을 한다는 점이다.즉, forward와 다르게 완전 새로운 요청을 하는 것이기 때문에 이전의 요청정보가 남아있지 않게된다.forward는 브라우저로 응답을 내려주지 않고, 서버에서 다른 URL로 이동해버린다.이는 REST API에서는 서버 내부에서 핸들러 포워딩 같은 형식으로는 동작하며, REST API가 아닌경우, 동적/정적 페이지 변환에 사용되는 개념이다. 서버내에서 이뤄지는 작업이기 때문에 클라이언트는 눈치챌 수 없다.서버가 요청정보를 가진상태로 다른 URL에 이동하기 때문에 이전 요청의 요청정보가 사라지지 않는다는 특징이 있다.HealthCheckMSA나 무중단배포 등의 아키텍처, 혹은 이중화 등을 구성하면 현재 서버상태를 확인할 수 있어야한다.게이트웨이나 프록시에서 서버상태가 정상인지 체크할 수 있어야 트래픽을 해당 방향으로 이동시킬 수 있기 때문이다.그렇다면 이 HealthCheck는 어떤 방식으로 이뤄질까?가장 먼저 떠오르는 방법은 전용 API를 구성하고, 해당 API로 요청을 보내보는 것이다. 만약, 정상적인 응답이 도착하면 해당 서버가 정상이라고 간주하여 트래픽을 해당 서버로 이동시킨다.손쉽게 서버 상태를 확인할 수 있긴 하지만, DB와 같은 외부시스템과의 연결이 정상인지 확인하는 과정이 누락된다.하지만, 해결법 또한 단순하다. 상태체크 API에 외부시스템 상태를 확인하는 코드를 추가하는 것이다.이런 상태체크 관련 기능을 Spring Boot에서는 Actuator 라는 서브 프로젝트(모듈)로 제공한다.Actuator는 /actuator라는 URL로 매핑되는 HealthCheck 엔드포인트를 제공해준다. ( 기본 /actuator/health )DB, Redis 등의 여러 외부시스템의 상태까지 확인하는게 가능하며, 특정 시스템을 제외하는 것도 가능하다.이런 HTTP를 이용한 HealthCheck 말고도 SSH를 이용해 직접 프로세스 상태를 확인하는 방법, Docker와 k8s 환경인 경우, k8s의 컨테이너 HealthCheck를 이용하는 방법 등이 존재한다.WebSocketSocket은 IP와 포트로 표현되며, 프로세스가 외부 시스템과 소통하기 위한 추상화된 장치다.그렇다면 WebSocket은 무엇일까?일반적인 HTTP 통신에서는 클라이언트가 서버측의 상태를 tracing 하려면 지속적으로 Request 를 보내야만 했다.이 방법은 실시간 동기화가 어려웠고, 네트워크 트래픽의 증가, 매 패킷에 포함되는 Header 등과 같은 문제들이 존재했다.WebSocket의 주 목적은 클라이언트와 서버간 지속적인 통신에 있다. 일반적인 HTTP 통신과 다르게 stateful 한 연결을 수립함으로써 네트워크 상의 두 노드들이 지속적으로 통신할 수 있게된다.기본적인 개념은 하나의 TCP연결을 끊지않고 계속해서 사용하는 것이다.WebSocket은 기존 TCP외에 추가적인 handshake 과정이 일어나며, 그 과정에서 Header를 통해 WebSocket 연결임을 표시한다.( 이때 일어나는 handshake는 TCP handshake가 성공한 다음 이뤄진다 )HTTP 요청을 받게 된 서버는 Header를 통해 해당 요청이 WebSocket 연결을 요구하는 것을 이해하고,응답을 통해 101 코드로 프로토콜의 변경사실을 클라이언트에게 알려준다.여기까지 진행하면 서버와 클라이언트는 서로 WebSocket 연결이 이뤄지고, 양방향 통신이 가능하게 된다.WebSocket 연결의 특징은 양방향 통신에 있다. 즉, 실시간 데이터 동기화에 유리하다.클라이언트가 요청을 보내지 않더라도 서버가 원하는 시점에 클라이언트로 정보를 전달 할 수 있다는 뜻이다.다만, 두 노드가 계속해서 연결을 유지해야 하기때문에 이와 관련된 리소스 지출이 있다.WebSocket이 적절한 서비스로는 채팅, 주식거래, 게임을 예시로 들 수 있다.WebSocket 연결을 끊을 때는 한쪽 노드에서의 1000번대의 상태코드와 함께 Closing Handshake가 일어나며,이후에는 TCP의 4-way shandshake와 함께 최종적으로 연결이 끊어진다.GET /chat HTTP/1.1Host: example.comUpgrade: websocketConnection: UpgradeSec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==Sec-WebSocket-Version: 13HTTP/1.1 101 Switching ProtocolsUpgrade: websocketConnection: UpgradeSec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=reqeuest 예시response 예시최종적으로 세션키 생성을 위해서는 총 3개의 값이 필요하다.1. 클라이언트 랜덤2. 서버 랜덤3. pre-master secret( 무작위 난수 )총 3개의 값을 결합하여 세션키를 생성하므로, 클라이언트 랜덤과 서버 랜덤은 모두 공개값이다.pre-master secret은 클라이언트가 생성하고, 서버의 pubkey로 암호화하여 공유한다.TCP keep-alive와 HTTP keep-aliveHTTP/1.0 이후로 keep-alive 기능이 추가되었고, HTTP/1.1 에서는 기본설정으로 적용된다. 이를통해, 매 요청마다 새로운 연결을 수립할 필요가 없어졌다. 그러나, keep-alive 기능은 HTTP 뿐만아니라 TCP에도 존재하는 기능이다.계층적으로 봤을때, HTTP의 경우 애플리케이션 계층 / TCP는 전송 계층에 해당한다.HTTP keep-alive의 경우, 애플리케이션(웹 서버)에서 관리하며 정해진 시간동안 다음 응답이 도착하는지를 확인하고 연결을 유지하는 기능이다. 이는 Connection: keep-alive 헤더를 통해 확인할 수 있다. TCP keep-alive의 경우, 전송계층이기에 관리 주체가 커널(OS)이다.현재 수립된 TCP 연결이 정상적인지 확인하는 역할을 한다.상대방의 ACK 패킷을 감지하면 연결이 유지되며, 응답이 없으면 재시도 끝에 연결을 종료한다.HTTP keep-alive는 여러 HTTP 요청을 하나의 TCP Connection 위에서 처리하기 위함이며TCP keep-alive의 경우, TCP 연결 자체가 살아있는지 확인하기 위함이다.애플리케이션 계층은 전송 계층 위에서 동작하므로, 두 keep-alive는 함께 사용될 수도 있다.다시한번 정리하자면, HTTP keep-alive는 애플리케이션 수준에서 TCP 연결을 유지하여 연결을 재사용함으로써 연결수립에 소모되는 리소스를 절약하는 기능이다.TCP keep-alive는 OS 수준에서 TCP 연결을 유지하기위해,연결의 상태를 확인하는 기능이다. 즉, TCP keep-alive로는 한 연결을 재사용할 수 없다.TCP Fast Open ( TFO )TCP 통신은 양측간의 신뢰보장을 위해 연결을 수립하는 과정을 가진다.이는 매 통신마다 발생하는 과정이기 때문에, 직전에 통신한 동일서버와 통신하더라도새롭게 연결을 수립하는 과정( 3-way handshake )이 일어난다.TFO는 이러한 반복적인 과정에서의 지연시간과 RTT를 줄이기 위한 수단이다.서버에서 클라이언트를 인증할 수 있는 보안 쿠키를 이용하여, 재 요청 시 3-way handshake(3WHS)의 첫 SYN에 쿠키와 데이터를 포함하여 전송하는 방식으로 동작한다.이렇게 되면 SYN - SYN/ACK - ACK 의 과정이후에 실제 데이터 교환이 일어나는 기존의 방식과 비교하여, 이미 SYN - SYN/ACK 시점에 데이터 교환이 일어나 RTT가 절약된다.표준 TCP와의 차이점은 수신측에서 애플리케이션에 데이터를 전달하는걸 금지하던 제한을 해제한다는 점이다.TCP의 초기 핸드쉐이크는 오래되거나 중복된 SYN을 걸러내는 역할을 하므로 기본적으로는 금지되지만,TFO를 활성화하면 이 제한을 해제할 수 있다.즉, TFO는 SYN 패킷에 데이터를 포함하여 초기 핸드쉐이크에서 데이터 교환이 가능하게 하는 것이다.중복 SYN과 관련된 예외처리가 생략되기 때문에, SYN 패킷이 중복되어도 상관없는 애플리케이션에서만 사용하도록 제한하는 것이 권장된다. 🌐https://datatracker.ietf.org/doc/html/rfc7413#section-1","aliases":[],"inlineTags":[],"frontmatterTags":["#excalidraw"],"headers":[],"links":[],"author":"","coverImageURL":"","fullURL":"공부/network.html","pathToRoot":"..","attachments":[],"createdTime":1741044818223,"modifiedTime":1748171435477,"sourceSize":109202,"sourcePath":"공부/Network.md","exportPath":"공부/network.html","showInTree":true,"treeOrder":14,"backlinks":[],"type":"excalidraw"},"공부/oidc-login(-oauth2.0-)요청-흐름.html":{"title":"OIDC Login( OAuth2.0 )요청 흐름","icon":"","description":"ClientResource OwnerResource ServerAuthorization ServerOAuth 2.0 Provider1. Client의 Authorization EntryPoint URL설정2. OAuth 2.0 로그인 요청4. 사용자 정보 인증 및 권한 허락5. Authorization Code가 포함된 Client URL로 redirect6. Authorization Code로 AccessToken, IDToken 요청7. AccessToken, IDToken 반환Authorization Code Authorization Code Grant 기준OIDC(OAuth2.0 확장 프토토콜 ) 로그인 흐름Authorization Server에게서 AccessToken과 ID Token을 얻어내기 위한 코드8. AccessToken으로 자원 요청9. 자원 반환Access Token사용자의 Resource 접근 권한이 포함된 토큰ID Token사용자의 인증 정보가 포함된 토큰Resource Server사용자 자원을 가진 OIDC Provider 서버Authorization Server사용자 인증을 위한 OIDC Provider 서버3. Authorization Server에 등록된EntryPoint로 redirectClientOAuth 2.0 로그인을 적용시키려는 서버Resource OwnerOIDC Provider의 회원10. 획득한 자원과 ID Token을 바탕으로회원 정보 등록 및 로그인 처리OAuth 2.0(Authorization)과 OIDC(Authentication)Spring Security에서 소셜 로그인을 구현해보면 내부적으로 OIDC 토큰과 OIDC 유저 객체를 생성하는 것을 확인할 수 있다.OIDC는 OpenID Connect 라는 프로토콜을 의미하며, 이는 사용자 인증(Authentication)을 수행하는 프로토콜을 뜻한다.일반적으로 소셜로그인에 언급되는 OAuth 2.0 프로토콜은 사용자 인가(Authorization)에 관련된 처리를 수행한다. 즉, OIDC로 사용자 인증을 수행하고, OAuth 2.0으로 생성된 유저의 권한을 확인하는 형식으로 소셜로그인이 이뤄진다.OIDC는 OAuth 2.0 기반으로 동작하는 일종의 구현체라고 볼 수 있다.OIDC에서는 ID Token에 사용자 인증정보가 포함되어 있으며, 이 토큰은 인가서버에서 Access &amp; RefreshToken과 함께 발급한다.이후, 이 토큰에 포함된 nonce 값을 OAuth 2.0 인가요청의 nonce 값과 비교하여 사용자를 식별처리한다.Spring Security 기준, OIDC 토큰을 이용해 OidcUser 객체를 생성하고, 이를 바탕으로 Authentication 객체를 생성한다.인가 서버에서 ID Token와 함께 AccessToken과 RefreshToken도 발급되며, Spring Security는 사용자 식별이 완료된 후, 해당 토큰들을 포함한 Authentication 객체를 생성하고 등록한다.이때, AccessToken과 RefreshToken은 JWT에서 토큰 탈취를 고려해서 구분되는 것과 동일한 용도를 지닌다. ( 이 토큰들은 로그인 후에도 지속적으로 소셜 서비스에 API 요청을 보내야 한다면 따로 관리해줘야 한다. )","aliases":[],"inlineTags":[],"frontmatterTags":["#excalidraw"],"headers":[],"links":[],"author":"","coverImageURL":"","fullURL":"공부/oidc-login(-oauth2.0-)요청-흐름.html","pathToRoot":"..","attachments":[],"createdTime":1739426978190,"modifiedTime":1748163414192,"sourceSize":33256,"sourcePath":"공부/OIDC Login( OAuth2.0 )요청 흐름.md","exportPath":"공부/oidc-login(-oauth2.0-)요청-흐름.html","showInTree":true,"treeOrder":15,"backlinks":[],"type":"excalidraw"},"공부/orm과-sql-mapper.html":{"title":"ORM과 SQL Mapper","icon":"","description":"Java와 데이터베이스서비스 운영에 있어서 데이터베이스는 필수적인 요소라고 볼 수 있다.비즈니스 로직을 처리하는 과정에서 데이터를 저장하고 조회하는 등의 작업이 필요하기 때문이다.비즈니스 로직은 프로그래밍 언어로 작성되고, 여기서는 Java를 가정하고 말할 생각이다.BE 서버와 DB를 구성한 상황에서 서버는 DB에 접근하기 위한 인터페이스가 필요하다. Java에서는 이를 위한 표준 인터페이스로 JDBC를 제공한다.JDBC는 Java를 이용해 DB에 접근하기 위한 과정을 추상화하여, 서로다른 서비스라도 동일한 방식의 접근방법을 제공하는 것을 목적으로 한다.JDBC의 동작흐름은 크게 3단계로 나뉜다.1. Driver를 이용해 DB와 연결 및 Connection 객체 생성2. Connection 객체에 Statement로 SQL 쿼리 전달3. SQL 쿼리의 결과를 ResultSet으로 받음데이터베이스와 연결을 수립하고, 이를 유지하기 위해서는 지속적인 리소스가 소모된다.이 비용을 줄이기 위해서는 생성된 객체들을 반환하고 연결을 끊어야할 필요가 있다.하지만, 서비스 동작에따라 연결은 지속적으로 생성된다.매번 연결수립과 해제를 반복하는 것은 비용적으로 좋지 못하다. 이를 해결하기 위한 방법이 DBCP 다.DBCP는 서비스가 실행될 때, DB와 특정 개수의 연결을 만들어놓고, 이를 재사용하는 방식으로 소모되는 자원을 아낀다.여기까지가 기초적인 배경지식이고, 이제 ORM과 SQL Mapper에 대해 알아보자앞선 방법을 통해 이미 추상화된 방법으로 Java에서 데이터베이스에 대한 접근이 가능해졌다.하지만, Java에서 표준으로 제공하는 API는 작성해야 하는 코드의 개수가 많았다.또한, 관리를 위해서는 개발자가 SQL 문법에 대한 이해도가 높아야한다. 즉, 유지보수가 쉽지않다.이러한 단점을 개선하기 위해 등장한 기술이 ORM과 SQL Mapper 다.이 두 기술은 새로운 API를 만들어내는 것이 아니라 개발자가 비즈니스 로직에 집중할 수 있도록보다 추상화되고 간편한 DB 접근방식을 제공한다. 즉, 내부적으로는 JDBC를 이용하고 있다.SQL Mapper(ex: MyBatis)ORM(ex: JPA )SQL Mapper는 별도의 파일에서 SQL 쿼리를 작성하고, 이를 Java 객체와 매핑시켜 데이터베이스와 상호작용하는 형식으로 동작한다.SQL을 직접 작성하기 때문에 복잡한 쿼리나 최적화가 필요한 작업들을처리하는데 이점이 있다. 대표적으로 MyBatis가 있는데, XML을 이용해 쿼리를 작성하고그 결과를 Java 객체로 매핑하는 방식으로 동작한다.예를든다면, XML의 &lt;select&gt; 태그에서 resultType으로 결과가 매핑될 객체를 지정하고 내부에 쿼리를 작성하는 방식이다.@Mapper로 Mapper 인터페이스를 지정해주고 내부에서 `org.apache.ibatis.annotations` 패키지 애노테이션을 사용하는 방식의사용도 가능하다&lt;mapper namespace=\"com.example.mapper.UserMapper\"&gt; &lt;!-- Select 쿼리: User 테이블에서 id로 사용자 정보를 조회 --&gt; &lt;select id=\"selectUser\" resultType=\"com.example.model.User\"&gt; SELECT id, name, email FROM users WHERE id = #{id} &lt;/select&gt;&lt;/mapper&gt;&lt; 예시 &gt; ORM은 객체와 DB 테이블을 직접적으로 매핑시키고, SQL 쿼리는 ORM에 맡기는 방식으로 동작한다. 개발자는 간단한 CRUD 등의 상황에서 SQL 쿼리를 작성할 필요가 없으며, 비즈니스 로직에 좀 더집중할 수 있다는 장점이 있다. ( 복잡한 쿼리나 성능 최적화가 필요한 땐 쿼리를 작성해야한다. )JPA는 JavaEE 에서 RDB를 관리하기 위한 API이며, 보통 Hibernate라는 구현체가 자주 사용된다. 만약, Spring 환경이라면 Spring Data JPA가 자주 사용된다. ( Spring Data JPA도 내부적으로는 Hibernate를 사용한다 )주요 특징은 DB 테이블과 객체가 매핑된다는 점이다.원격저장소 등을 사용하는 상황에서 테이블이 외부에 노출될 수 있다는 단점도 있지만,초기 세팅을 완료하면 개발자의 쿼리관련 고민을 줄일 수 있다는 장점이 있다.데이터베이스와 직접적으로 소통하는 인터페이스를 Repository라고 부르며,해당 인터페이스 내의 Method 명명규칙에 따라 생성되는 쿼리가 정해진다.예를들어, findByUserId(userId) 이런 이름이라면 userId를 이용해 매핑되는 테이블로 SELECT 쿼리를 날리는 방식이다.매 요청마다 데이터베이스로 쿼리를 날리면 네트워크 비용 등의 문제가 생긴다.이를 줄이기 위해서 JPA는 영속성 컨텍스트라는 중간 저장소개념을 가지고 있다.영속성 컨텍스트는 트랜잭션 내의 요청들을 보관하고 있다가 특정시점에 일괄적으로 DB에 요청한다. 즉, JPA는 트랜잭션의 기능을 수행할 수 있다. ( 쓰기 관련 요청들만 해당하며, 읽기 요청은 필요에 따라 바로바로 DB를 거쳐 1차 캐시에 저장한다 )이 때문에 영속성 컨텍스트에 보관된 쿼리정보가 DB로 전달되기 이전에 시스템 문제가 생긴다면결과가 정상적으로 반영되지 않을 수 있다.영속성 컨텍스트에 한번 영속(Persist)된 객체는 트랜잭션이 끝날 때까지 Entity로써 동작한다.즉, 해당 Entity의 값을 수정하면 UPDATE 쿼리가 발생한다는 의미다.영속성 컨텍스트에 보관된 쿼리들이 한번에 DB로 전달되는 시점은 flush() 가 호출된 경우다.직접 쿼리를 작성하는 상황에서는 보통 @Query나 QueryDSL 같은 라이브러리를 쓴다.@Query의 경우 JPQL 이라는 언어를 쓰거나, Native Query를 쓴다.QueryDSL은 동적 쿼리생성을 지원하기 때문에해당 기능이 필요하다면 이 라이브러리를 사용하자지연로딩1:N이나 N:M 관계인 경우. 특정 테이블의 튜플을 읽었을 때관련된 다수의 튜플들이 함께 읽어져야 하는 상황이 있다.이 경우, 하나의 Entity을 읽었을 뿐인데 다수의 쿼리가연달아 발생하는 경우가 생기며, N+1 문제로 불린다.지연로딩을 이용하여 연관된 Entity 정보를 읽어올 시점을 지정하는 방법으로 개선이 가능하다.기본 로딩전략은 즉시로딩이기 때문에, 이를 지연로딩으로 바꿔주면 실제로 해당 튜플이 필요한 시점에 쿼리가 발생하도록할 수 있다.N+1 문제지연로딩을 통해 N+1 문제를 해결할 수 있는 것처럼 작성했지만, 결국 쿼리의 발생 시점을 늦출 뿐이다. 즉, 발생하는 쿼리의 수를 줄이지는 못한다.이를 해결하기 위한 방법은 크게 2가지로 나뉜다.1. Join을 통해 하나의 테이블로 받아오기2. 특정 크기를 정해서 그 단위로 받아오기1번 방법의 경우, `join fetch` or `@EntityGraph`를 사용하는 방법으로 나뉜다.둘 다 Eager Join으로 데이터를 가져와야 한다`join fetch`는 Inner Join으로 가져오기 때문에 페이징처리가 불가능하고 데이터가 중복될 수 있다는 단점이 있다.`@EntityGraph`는 Left Outer Join을 사용하기에 결과값으로 NULL이 올 수 있다.2번 방법의 경우, 지연로딩을 전제로 하여 추가 쿼리가 발생해야하는 상황에서 IN 쿼리를 이용하여 정해진 BatchSize 만큼만 가져오도록 설정하는 방법이다.현재 Table의 PK를 이용해 BatchSize 만큼 대상 테이블에서 IN(1, 2 ... ) 이런식으로 작성된다. 즉, 세부조회를 시도하면 Lazy하게 하나의 추가쿼리가 발생한다.EX: BatchSize가 10인 경우SELECT c.id, c.description, c.post_id FROM Command c WHERE c.post_id = 1 AND c.id IN (1, 2, 3, 4, 5, 6, 7, 8, 9, 10);1:N 관계에서 1에 해당되는 테이블을 조회하면서N을 inner join 하면 기존의 테이블 레코드보다 증가하게 되면서제대로된 페이징이 불가능해진다반대의 상황(N:1)은 상관없다","aliases":[],"inlineTags":[],"frontmatterTags":["#excalidraw"],"headers":[],"links":[],"author":"","coverImageURL":"","fullURL":"공부/orm과-sql-mapper.html","pathToRoot":"..","attachments":[],"createdTime":1741044818201,"modifiedTime":1755086023407,"sourceSize":37551,"sourcePath":"공부/ORM과 SQL Mapper.md","exportPath":"공부/orm과-sql-mapper.html","showInTree":true,"treeOrder":16,"backlinks":[],"type":"excalidraw"},"공부/web-application과-spring-동작.html":{"title":"Web Application과 Spring 동작","icon":"","description":"KernelUserCPURAMHDD, SSD ....H/WS/WOSWeb ServerKernelUserCPURAMHDD, SSD ....H/WS/WOSNICNICLink ( Frame )Internet IP(Packet)Tansport TCP(Segment), UDP(Datagram) socketWeb ServerWASBackendLink ( Frame )Internet IP(Packet)Tansport TCP(Segment), UDP(Datagram) socket정적 페이지 호출InternetInternetFrontEndAPI 호출DBSpring SecurityWeb Application Server(Tomcat)SpringFilterFilterFilterDelegatingFilterProxySecurityFilterChain#0Bean FilterSecurity Filter#0Security Filter#1Security Filter#NSecurity Filter#0Security Filter#1Security Filter#2Security Filter#0Security Filter#1Security Filter#2SecurityFilterChain#1SecurityFilterChain#2SpringSpring Security에서 실제로 필터로 등록되는 클래스는 `DelegatingFilterProxy` 사용자가 작성한 필터들은 Spring 내부에 위치하며, 프록시 객체가 Spring 내부의 필터들을 호출하는 방식으로 동작필터체인에 기본적으로 등록되는 필터들에는 CORS, CSRF 등의 보안 필터가 포함되어있고,동작순서는 `FilterOrderRegistration` 클래스에서 확인할 수 있음Spring Security 동작흐름SecurityFilterChain보안 필터 : CSRF, CORS 등 인증 필터 : Authentication 생성인가 필터 : Authentication 내의 권한 확인인증 필터는 요청을 분석하여 Authentication 객체를 생성함( 요청내의 인증정보를 바탕으로 )SecurityContextHolderSecurityContext사용자 식별, 비밀번호, 인가정보Authentication인가 필터는 현재 SecurityContextHolder에 담긴 Authentication을확인하고, 인가정보가 현재 요청 목적지에 해당하는 권한인지 확인함권한이 없다면 403 / Authentication이 없으면 401 발생1. Filter 동작시점에 WebApplicationContext가 초기화 되었을수도 있고, 아닐수도 있다.2. WAC가 초기화되었더라도 Filter 입장에서는 이를 확인할 방법이 없으므로, 없다고 가정한다.3. 2번에 의해 Filter는 일반적으로 Spring 기능을 이용할 수 없다.4. DelegatingFilterProxy는 Filter 수준에서 WAC가 존재하는지 검증하는 역할을 한다.5. 4.로 인해 SpringSecurity는 필터에서 Spring 기능을 사용할 수 있다.Web ServerWAS상황에 따라서는 Spring 내장Spring MVCDBDispatcherServletHandlerMappringControllerServiceViewResolverFilterSpring SecuritySpring MVC 동작흐름InterceptorWeb Application ServerWAS는 웹 서비스 환경에서 Web Server와 함께 중요한 구성요소로 자리하고 있다. 보통 WebServer는 정적 페이지를 관리하고, WAS 동적 페이지를 관리하는 것으로 구분된다.그렇다면 React와 같이 별도의 Front 서버가 존재하는 상황에서 WebServer와 WAS는 어떤 역할을 수행할까?인터넷을 통해 PC로 들어온 요청은 NIC를 거쳐 웹 서버로 도착할 것이다. FrontEnd 프레임워크는 빌드를 통해 정적파일들을 생성하고, WebServer에서는 이를 호스팅하는 방식으로 동작한다.즉, FE 서버는 첫 빌드를 통해 웹 서버로 정적파일을 호스팅한 다음에는 동작하고 있지 않아도 된다.정리하자면 FE 서버는 실시간으로 동작하지 않아도 되며, 웹 서버는 FE에게 호스팅받은 정적파일을 클라이언트에게 반환한다.이제 남은 부분은 동적 페이지와 API 처리다.SPA 프레임워크와 함께 사용된다면 REST API 일 것이고, BackEnd 서버에서 페이지 처리까지 한다면(SSR) 동적 페이지 요청이 된다.WAS는 웹 서버와 BE 서버 사이에서 일종의 프록시 역할을 한다.즉, 두 서버 사이에서 요청이 어느 BE서버로 전달되어야 하는지 라우팅하는 역할을 맡는다.( 만약, /auth/** 로 요청이 왔다면 이를 인증처리 서버로 이동시키는 동작을 하는 것이다. )이렇게 생각해보면 WAS와 DispatcherServlet 사이에서 동작하는 Filter의 역할도 이해에 도움이된다.실제 비즈니스 처리 이전에 동작하기 때문에, 처리에 원활한 인코딩 형식인지? 또는 보안처리를 해내는데 적합한 위치다.여기까지 오면 Spring이 WAS랑 유사한데? 라는 생각을 할 수 있다.Spring 자체는 비즈니스 처리와 세션관리, 다른 서비스와의 통신 등을 담당하는 로직을 처리한다.이는 원래 WAS에서 수행되던 동작이었으나, Spring 에 오면서 해당 부분을 추상화하여 독립적으로 관리하게 해준 것이다.Servlet이나 JSP를 Java환경으로 개발한 프로그램은 그 자체로 WAS이며, Spring은 추상화를 통해 WAS와 구분된 작업환경을제공하는 것이다.즉, 서블릿 컨테이너로써의 WAS(Tomcat)은 여러 Spring 서버의 Servlet( DispatcherServlet )으로 요청을 라우팅하는 역할을 한다.실제로 Docker 컨테이너로 Tomcat을 구동하고, Spring 프로젝트 여럿을 war파일로 제공 및 설정해주면 분기되게 할 수 있다.WAS와 BE 양쪽에 독립적인 위치를 지향Tomcat =&gt; 서블릿 컨테이너( 요청 라우팅 )WAS =&gt; 서블릿 컨테이너 + 비즈니스 로직즉, Tomcat은 경량화된 WAS( forbidden )( UnAuthorized )글을 읽다보면 헷갈릴 수 있는데, 전통적인 WAS는 비즈니스 처리와 동적 페이지 반환까지 해내는 SSR 같은 서버를 의미한다.Spring에서 WAS는 서블릿 컨테이너로, 요청이 어느 서블릿으로 향할지를 결정짓는 역할을 한다( 대표적으로 Tomcat )이 필터 체인의 순서는 FilterOrderRegistration 에서 확인할 수 있다.대략===COSRCSRFLogoutAuthentication(인증)Authorization(인가)===의 순서로 진행된다.이후에는 다시 Application의 필터동작 흐름으로 돌아간다","aliases":[],"inlineTags":[],"frontmatterTags":["#excalidraw"],"headers":[],"links":[],"author":"","coverImageURL":"","fullURL":"공부/web-application과-spring-동작.html","pathToRoot":"..","attachments":[],"createdTime":1741044818172,"modifiedTime":1748151817883,"sourceSize":87450,"sourcePath":"공부/Web Application과 Spring 동작.md","exportPath":"공부/web-application과-spring-동작.html","showInTree":true,"treeOrder":17,"backlinks":[],"type":"excalidraw"}},"sourceToTarget":{"공부/이미지/1-hexagonal-architecture.png":"공부/이미지/1-hexagonal-architecture.html","공부/이미지/3-Tier 아키텍처.png":"공부/이미지/3-tier-아키텍처.html","공부/이미지/Pasted Image 20250315205713_441.png":"공부/이미지/pasted-image-20250315205713_441.html","공부/데이터베이스.md":"공부/데이터베이스.html","공부/컴퓨터 구조.md":"공부/컴퓨터-구조.html","공부/프록시.md":"공부/프록시.html","공부/헥사고날 아키텍처.md":"공부/헥사고날-아키텍처.html","공부/BE 아키텍처 기초.md":"공부/be-아키텍처-기초.html","공부/CORS, XSS, CSRF.md":"공부/cors,-xss,-csrf.html","공부/Java 기초.md":"공부/java-기초.html","공부/JDK, JRE, JVM.md":"공부/jdk,-jre,-jvm.html","공부/Json Web Token.md":"공부/json-web-token.html","공부/Network.md":"공부/network.html","공부/OIDC Login( OAuth2.0 )요청 흐름.md":"공부/oidc-login(-oauth2.0-)요청-흐름.html","공부/ORM과 SQL Mapper.md":"공부/orm과-sql-mapper.html","공부/Web Application과 Spring 동작.md":"공부/web-application과-spring-동작.html","":"site-lib/styles/supported-plugins.css"},"featureOptions":{"backlinks":{"featureId":"backlinks","enabled":true,"unavailable":false,"alwaysEnabled":false,"hideSettingsButton":false,"featurePlacement":{"selector":".footer","type":"start","info_selector":{"show":true,"name":"","description":"CSS selector for an element. The feature will be placed relative to this element.","placeholder":""},"info_type":{"show":true,"name":"","description":"Will this feature be placed before, after, or inside (at the beggining or end).","placeholder":"","dropdownOptions":{"Before":"before","After":"after","Start":"start","End":"end"}}},"info_featurePlacement":{"show":true,"name":"","description":"Where to place this feature on the page. (Relative to the selector)","placeholder":""},"displayTitle":"Backlinks","info_displayTitle":{"show":true,"name":"","description":"Descriptive title to show above the feature","placeholder":""}},"tags":{"featureId":"tags","enabled":false,"unavailable":false,"alwaysEnabled":false,"hideSettingsButton":false,"featurePlacement":{"selector":".header .data-bar","type":"end","info_selector":{"show":true,"name":"","description":"CSS selector for an element. The feature will be placed relative to this element.","placeholder":""},"info_type":{"show":true,"name":"","description":"Will this feature be placed before, after, or inside (at the beggining or end).","placeholder":"","dropdownOptions":{"Before":"before","After":"after","Start":"start","End":"end"}}},"info_featurePlacement":{"show":true,"name":"","description":"Where to place this feature on the page. (Relative to the selector)","placeholder":""},"displayTitle":"","info_displayTitle":{"show":true,"name":"","description":"Descriptive title to show above the feature","placeholder":""},"showInlineTags":true,"showFrontmatterTags":true,"info_showInlineTags":{"show":true,"name":"","description":"Show tags defined inside the document at the top of the page.","placeholder":""},"info_showFrontmatterTags":{"show":true,"name":"","description":"Show tags defined in the frontmatter of the document at the top of the page.","placeholder":""}},"alias":{"featureId":"aliases","enabled":false,"unavailable":false,"alwaysEnabled":false,"hideSettingsButton":false,"featurePlacement":{"selector":".header .data-bar","type":"start","info_selector":{"show":true,"name":"","description":"CSS selector for an element. The feature will be placed relative to this element.","placeholder":""},"info_type":{"show":true,"name":"","description":"Will this feature be placed before, after, or inside (at the beggining or end).","placeholder":"","dropdownOptions":{"Before":"before","After":"after","Start":"start","End":"end"}}},"info_featurePlacement":{"show":true,"name":"","description":"Where to place this feature on the page. (Relative to the selector)","placeholder":""},"displayTitle":"Aliases","info_displayTitle":{"show":true,"name":"","description":"Descriptive title to show above the feature","placeholder":""}},"properties":{"featureId":"properties","enabled":true,"unavailable":false,"alwaysEnabled":false,"hideSettingsButton":false,"featurePlacement":{"selector":".header","type":"start","info_selector":{"show":true,"name":"","description":"CSS selector for an element. The feature will be placed relative to this element.","placeholder":""},"info_type":{"show":true,"name":"","description":"Will this feature be placed before, after, or inside (at the beggining or end).","placeholder":"","dropdownOptions":{"Before":"before","After":"after","Start":"start","End":"end"}}},"info_featurePlacement":{"show":true,"name":"","description":"Where to place this feature on the page. (Relative to the selector)","placeholder":""},"displayTitle":"Properties","info_displayTitle":{"show":true,"name":"","description":"Descriptive title to show above the feature","placeholder":""},"info_hideProperties":{"show":true,"name":"","description":"A list of properties to hide from the properties view","placeholder":""}},"fileNavigation":{"featureId":"file-navigation","enabled":true,"unavailable":false,"alwaysEnabled":false,"hideSettingsButton":false,"featurePlacement":{"selector":"#left-sidebar-content","type":"end","info_selector":{"show":true,"name":"","description":"CSS selector for an element. The feature will be placed relative to this element.","placeholder":""},"info_type":{"show":true,"name":"","description":"Will this feature be placed before, after, or inside (at the beggining or end).","placeholder":"","dropdownOptions":{"Before":"before","After":"after","Start":"start","End":"end"}}},"info_featurePlacement":{"show":true,"name":"","description":"Where to place this feature on the page. (Relative to the selector)","placeholder":""},"info_includePath":{"show":false,"name":"","description":"","placeholder":""},"showCustomIcons":false,"showDefaultFolderIcons":false,"showDefaultFileIcons":false,"defaultFolderIcon":"lucide//folder","defaultFileIcon":"lucide//file","defaultMediaIcon":"lucide//file-image","exposeStartingPath":true,"info_showCustomIcons":{"show":true,"name":"","description":"Show custom icons for files and folders","placeholder":""},"info_showDefaultFolderIcons":{"show":true,"name":"","description":"Show a default icon of a folder for every folder in the tree","placeholder":""},"info_showDefaultFileIcons":{"show":true,"name":"","description":"Show a default icon of a file for every file in the tree","placeholder":""},"info_defaultFolderIcon":{"show":true,"name":"","description":"The icon to use for folders. Prefix with 'lucide//' to use a Lucide icon","placeholder":""},"info_defaultFileIcon":{"show":true,"name":"","description":"The icon to use for files. Prefix with 'lucide//' to use a Lucide icon","placeholder":""},"info_defaultMediaIcon":{"show":true,"name":"","description":"The icon to use for media files. Prefix with 'lucide//' to use a Lucide icon","placeholder":""},"info_exposeStartingPath":{"show":true,"name":"","description":"Whether or not to show the current file in the file tree when the page is first loaded","placeholder":""},"includePath":"site-lib/html/file-tree.html"},"search":{"featureId":"search","enabled":true,"unavailable":false,"alwaysEnabled":false,"hideSettingsButton":false,"featurePlacement":{"selector":"#left-sidebar .topbar-content","type":"start","info_selector":{"show":true,"name":"","description":"CSS selector for an element. The feature will be placed relative to this element.","placeholder":""},"info_type":{"show":true,"name":"","description":"Will this feature be placed before, after, or inside (at the beggining or end).","placeholder":"","dropdownOptions":{"Before":"before","After":"after","Start":"start","End":"end"}}},"info_featurePlacement":{"show":true,"name":"","description":"Where to place this feature on the page. (Relative to the selector)","placeholder":""},"displayTitle":"Search...","info_displayTitle":{"show":true,"name":"","description":"Descriptive title to show above the feature","placeholder":""}},"outline":{"featureId":"outline","enabled":false,"unavailable":false,"alwaysEnabled":false,"hideSettingsButton":false,"featurePlacement":{"selector":"#right-sidebar-content","type":"end","info_selector":{"show":true,"name":"","description":"CSS selector for an element. The feature will be placed relative to this element.","placeholder":""},"info_type":{"show":true,"name":"","description":"Will this feature be placed before, after, or inside (at the beggining or end).","placeholder":"","dropdownOptions":{"Before":"before","After":"after","Start":"start","End":"end"}}},"info_featurePlacement":{"show":true,"name":"","description":"Where to place this feature on the page. (Relative to the selector)","placeholder":""},"displayTitle":"Outline","info_displayTitle":{"show":true,"name":"","description":"Descriptive title to show above the feature","placeholder":""},"startCollapsed":false,"minCollapseDepth":0,"info_startCollapsed":{"show":true,"name":"","description":"Should the outline start collapsed?","placeholder":""},"info_minCollapseDepth":{"show":true,"name":"","description":"Only allow outline items to be collapsed if they are at least this many levels deep in the tree.","placeholder":"","dropdownOptions":{"1":1,"2":2,"No Collapse":100}}},"themeToggle":{"featureId":"theme-toggle","enabled":true,"unavailable":false,"alwaysEnabled":false,"hideSettingsButton":false,"featurePlacement":{"selector":"#left-sidebar .topbar-content","type":"start","info_selector":{"show":true,"name":"","description":"CSS selector for an element. The feature will be placed relative to this element.","placeholder":""},"info_type":{"show":true,"name":"","description":"Will this feature be placed before, after, or inside (at the beggining or end).","placeholder":"","dropdownOptions":{"Before":"before","After":"after","Start":"start","End":"end"}}},"info_featurePlacement":{"show":true,"name":"","description":"Where to place this feature on the page. (Relative to the selector)","placeholder":""},"displayTitle":"","info_displayTitle":{"show":true,"name":"","description":"Descriptive title to show above the feature","placeholder":""}},"graphView":{"featureId":"graph-view","enabled":false,"unavailable":false,"alwaysEnabled":false,"hideSettingsButton":false,"featurePlacement":{"selector":"#right-sidebar-content","type":"start","info_selector":{"show":true,"name":"","description":"CSS selector for an element. The feature will be placed relative to this element.","placeholder":""},"info_type":{"show":true,"name":"","description":"Will this feature be placed before, after, or inside (at the beggining or end).","placeholder":"","dropdownOptions":{"Before":"before","After":"after","Start":"start","End":"end"}}},"info_featurePlacement":{"show":true,"name":"","description":"Where to place this feature on the page. (Relative to the selector)","placeholder":""},"displayTitle":"Graph View","info_displayTitle":{"show":true,"name":"","description":"Descriptive title to show above the feature","placeholder":""},"showOrphanNodes":true,"showAttachments":false,"allowGlobalGraph":true,"allowExpand":true,"attractionForce":1,"linkLength":15,"repulsionForce":80,"centralForce":2,"edgePruning":100,"minNodeRadius":3,"maxNodeRadius":7,"info_showOrphanNodes":{"show":true,"name":"","description":"Show nodes that are not connected to any other nodes.","placeholder":""},"info_showAttachments":{"show":true,"name":"","description":"Show attachments like images and PDFs as nodes in the graph.","placeholder":""},"info_allowGlobalGraph":{"show":true,"name":"","description":"Allow the user to view the global graph of all nodes.","placeholder":""},"info_allowExpand":{"show":true,"name":"","description":"Allow the user to pop-out the graph view to take up the whole screen","placeholder":""},"info_attractionForce":{"show":true,"name":"","description":"How much should linked nodes attract each other? This will make the graph appear more clustered.","placeholder":""},"info_linkLength":{"show":true,"name":"","description":"How long should the links between nodes be? The shorter the links the more connected nodes will cluster together.","placeholder":""},"info_repulsionForce":{"show":true,"name":"","description":"How much should nodes repel each other? This will make disconnected parts more spread out.","placeholder":""},"info_centralForce":{"show":true,"name":"","description":"How much should nodes be attracted to the center? This will make the graph appear more dense and circular.","placeholder":""},"info_edgePruning":{"show":true,"name":"","description":"Edges with a length above this threshold will not be rendered, however they will still contribute to the simulation. This can help large tangled graphs look more organised. Hovering over a node will still display these links.","placeholder":""},"info_minNodeRadius":{"show":true,"name":"","description":"How small should the smallest nodes be? The smaller a node is the less it will attract other nodes.","placeholder":""},"info_maxNodeRadius":{"show":true,"name":"","description":"How large should the largest nodes be? Nodes are sized by how many links they have. The larger a node is the more it will attract other nodes. This can be used to create a good grouping around the most important nodes.","placeholder":""}},"sidebar":{"featureId":"sidebar","enabled":true,"unavailable":false,"alwaysEnabled":false,"hideSettingsButton":false,"allowResizing":true,"allowCollapsing":true,"rightDefaultWidth":"20em","leftDefaultWidth":"20em","info_allowResizing":{"show":true,"name":"","description":"Whether or not to allow the sidebars to be resized","placeholder":""},"info_allowCollapsing":{"show":true,"name":"","description":"Whether or not to allow the sidebars to be collapsed","placeholder":""},"info_rightDefaultWidth":{"show":true,"name":"","description":"The default width of the right sidebar","placeholder":""},"info_leftDefaultWidth":{"show":true,"name":"","description":"The default width of the left sidebar","placeholder":""}},"customHead":{"featureId":"custom-head","enabled":true,"unavailable":false,"alwaysEnabled":false,"hideSettingsButton":false,"featurePlacement":{"selector":"head","type":"end","info_selector":{"show":true,"name":"","description":"CSS selector for an element. The feature will be placed relative to this element.","placeholder":""},"info_type":{"show":true,"name":"","description":"Will this feature be placed before, after, or inside (at the beggining or end).","placeholder":"","dropdownOptions":{"Before":"before","After":"after","Start":"start","End":"end"}}},"info_featurePlacement":{"show":true,"name":"","description":"Where to place this feature on the page. (Relative to the selector)","placeholder":""},"info_includePath":{"show":false,"name":"","description":"","placeholder":""},"sourcePath":"","info_sourcePath":{"show":true,"name":"","description":"The local path to the source .html file which will be included.","placeholder":"","fileInputOptions":{"makeRelativeToVault":true,"browseButton":true}},"includePath":"site-lib/html/custom-head.html"},"document":{"featureId":"obsidian-document","enabled":true,"unavailable":false,"alwaysEnabled":true,"hideSettingsButton":false,"allowFoldingLists":true,"allowFoldingHeadings":true,"documentWidth":"40em","info_allowFoldingLists":{"show":true,"name":"","description":"Whether or not to allow lists to be folded","placeholder":""},"info_allowFoldingHeadings":{"show":true,"name":"","description":"Whether or not to allow headings to be folded","placeholder":""},"info_documentWidth":{"show":true,"name":"","description":"The width of the document","placeholder":""}},"rss":{"featureId":"rss","enabled":false,"unavailable":false,"alwaysEnabled":false,"hideSettingsButton":false,"siteUrl":"","authorName":"","info_siteUrl":{"show":true,"name":"","description":"The url that this site will be hosted at","placeholder":"https://example.com/mysite"},"info_authorName":{"show":true,"name":"","description":"The name of the author of the site","placeholder":""}},"linkPreview":{"featureId":"link-preview","enabled":false,"unavailable":false,"alwaysEnabled":false,"hideSettingsButton":true}},"modifiedTime":1755086041014,"siteName":"Obsidian Vault","exportRoot":"","baseURL":"","themeName":"","bodyClasses":"publish css-settings-manager show-inline-title show-ribbon is-focused","hasFavicon":false}